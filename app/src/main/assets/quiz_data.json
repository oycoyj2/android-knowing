[
  {
    "question": "CPU와 메모리 간의 데이터 흐름을 간단히 설명하세요.",
    "answer": "CPU는 메모리에서 데이터를 가져와 연산을 수행하고, 그 결과를 다시 메모리에 저장합니다. 이를 위해 데이터 버스와 주소 버스를 사용하여 메모리와 통신합니다.",
    "categoryId": 1
  },
  {
    "question": "캐시 메모리의 역할은 무엇인가요?",
    "answer": "캐시 메모리는 CPU와 주 메모리(RAM) 사이에서 데이터를 임시로 저장하여 CPU가 자주 접근하는 데이터를 빠르게 읽을 수 있도록 해주는 메모리 계층입니다.",
    "categoryId": 1
  },
  {
    "question": "캐시 미스(Cache Miss)가 발생하면 성능에 어떤 영향을 미치나요?",
    "answer": "캐시 미스가 발생하면 CPU는 데이터를 캐시에서 찾지 못해 메인 메모리에서 데이터를 가져와야 하므로 데이터 접근 속도가 느려지고 시스템 성능이 저하됩니다.",
    "categoryId": 1
  },
  {
    "question": "멀티코어 프로세서가 중요한 이유는 무엇인가요?",
    "answer": "멀티코어 프로세서는 여러 작업을 동시에 처리할 수 있어 병렬 처리를 가능하게 하고, 성능 향상 및 전력 효율성을 높일 수 있습니다.",
    "categoryId": 1
  },
  {
    "question": "가상 메모리가 실무에서 중요한 이유는 무엇인가요?",
    "answer": "가상 메모리는 물리적 메모리의 크기를 넘는 데이터도 실행할 수 있게 해주며, 메모리 부족 문제를 해결하고 프로그램의 안정성을 보장합니다.",
    "categoryId": 1
  },
  {
    "question": "메모리 계층 구조에서 각 계층의 역할은 무엇인가요?",
    "answer": "레지스터, 캐시, RAM, 디스크 순으로 계층이 나뉘며, 레지스터는 CPU 내부에서 가장 빠르고, 캐시는 CPU와 RAM 사이에서 자주 사용되는 데이터를 저장, RAM은 프로그램 실행 데이터를 저장, 디스크는 영구 저장 장치 역할을 합니다.",
    "categoryId": 1
  },
  {
    "question": "파이프라이닝(Pipelining)이란 무엇인가요?",
    "answer": "파이프라이닝은 CPU에서 명령어를 여러 단계로 나누어 각 단계별로 동시에 처리하는 방식으로, 처리 속도를 높이는 데 기여합니다.",
    "categoryId": 1
  },
  {
    "question": "파이프라인 하자드(Pipeline Hazard)란 무엇인가요?",
    "answer": "파이프라인 하자드는 명령어 간의 의존성 때문에 파이프라인이 제대로 동작하지 못해 발생하는 문제로, 데이터 하자드, 제어 하자드, 구조적 하자드가 있습니다.",
    "categoryId": 1
  },
  {
    "question": "I/O 병목 현상이 발생하는 이유는 무엇인가요?",
    "answer": "I/O 장치가 CPU보다 속도가 느리기 때문에 데이터 입출력 과정에서 CPU가 대기하게 되어 병목 현상이 발생합니다.",
    "categoryId": 1
  },
  {
    "question": "I/O 병목 현상을 해결하는 방법은 무엇인가요?",
    "answer": "DMA(Direct Memory Access)와 같은 기술을 사용하여 CPU 개입 없이 메모리와 I/O 장치 간 직접적인 데이터 전송을 가능하게 하여 병목을 해결할 수 있습니다.",
    "categoryId": 1
  },
  {
    "question": "분기 예측(Branch Prediction)이란 무엇인가요?",
    "answer": "분기 예측은 CPU가 조건부 명령어를 실행할 때 다음 실행될 명령어를 미리 예측하여 파이프라인 효율성을 높이는 기술입니다.",
    "categoryId": 1
  },
  {
    "question": "분기 예측이 정확하지 않으면 어떤 문제가 발생하나요?",
    "answer": "분기 예측이 잘못되면 잘못된 경로로 명령어가 실행되어 파이프라인이 비워지고, 이는 성능 저하로 이어집니다.",
    "categoryId": 1
  },
  {
    "question": "메모리 정렬(Memory Alignment)이 중요한 이유는 무엇인가요?",
    "answer": "메모리 정렬이 맞지 않으면 CPU가 데이터를 읽고 쓰는 데 더 많은 클럭 사이클을 소비하게 되어 성능이 저하됩니다.",
    "categoryId": 1
  },
  {
    "question": "CPU 캐시 일관성(Cache Coherence) 문제란 무엇인가요?",
    "answer": "멀티코어 시스템에서 각 코어의 캐시에 동일한 메모리 주소를 가진 데이터가 있을 때, 한 코어가 데이터를 수정하면 다른 코어의 캐시가 이를 반영하지 못하는 문제를 일컫습니다.",
    "categoryId": 1
  },
  {
    "question": "캐시 일관성 문제를 해결하는 방법은 무엇인가요?",
    "answer": "MESI 프로토콜과 같은 캐시 일관성 메커니즘을 사용하여 캐시 데이터의 일관성을 유지할 수 있습니다.",
    "categoryId": 1
  },
  {
    "question": "가상 메모리에서 페이지 폴트(Page Fault)란 무엇인가요?",
    "answer": "페이지 폴트는 CPU가 참조하려는 메모리 페이지가 물리적 메모리에 없을 때 발생하며, 운영체제가 디스크에서 해당 페이지를 메모리로 불러옵니다.",
    "categoryId": 1
  },
  {
    "question": "TLB(Translation Lookaside Buffer)의 역할은 무엇인가요?",
    "answer": "TLB는 가상 주소를 물리적 주소로 변환할 때 자주 사용되는 페이지 테이블 항목을 캐싱하여 메모리 접근 속도를 높여줍니다.",
    "categoryId": 1
  },
  {
    "question": "하이퍼스레딩(Hyper-Threading)이란 무엇인가요?",
    "answer": "하이퍼스레딩은 하나의 CPU 코어에서 두 개의 스레드를 동시에 실행할 수 있도록 하여 효율성을 높이는 기술입니다.",
    "categoryId": 1
  },
  {
    "question": "하이퍼스레딩이 유용한 이유는 무엇인가요?",
    "answer": "하이퍼스레딩을 통해 CPU는 대기 시간을 줄이고, 더 많은 작업을 동시에 처리할 수 있어 성능을 향상시킵니다.",
    "categoryId": 1
  },
  {
    "question": "RISC와 CISC의 차이점은 무엇인가요?",
    "answer": "RISC는 단순하고 빠른 명령어를 사용하는 프로세서 구조이고, CISC는 복잡한 명령어를 사용하여 더 적은 명령으로 작업을 처리하려는 구조입니다.",
    "categoryId": 1
  },
  {
    "question": "RISC의 장점은 무엇인가요?",
    "answer": "RISC는 단순한 명령어 세트를 사용하여 더 빠른 속도로 명령어를 처리할 수 있으며, 파이프라이닝 성능이 뛰어납니다.",
    "categoryId": 1
  },
  {
    "question": "CISC의 장점은 무엇인가요?",
    "answer": "CISC는 복잡한 명령어를 사용하여 메모리 접근을 줄이고, 한 번의 명령어로 복잡한 작업을 처리할 수 있습니다.",
    "categoryId": 1
  },
  {
    "question": "프로세서의 클럭 속도와 성능은 어떻게 관련이 있나요?",
    "answer": "클럭 속도는 초당 실행할 수 있는 명령어의 수를 결정하며, 더 높은 클럭 속도는 더 빠른 명령어 처리로 이어집니다.",
    "categoryId": 1
  },
  {
    "question": "클럭 속도가 높다고 항상 성능이 더 좋은 것은 아닌 이유는 무엇인가요?",
    "answer": "클럭 속도가 높더라도 캐시 미스, 메모리 대기 시간, 열 문제 등이 성능에 영향을 미칠 수 있습니다.",
    "categoryId": 1
  },
  {
    "question": "프로세서에서 SIMD 명령어는 무엇인가요?",
    "answer": "SIMD는 하나의 명령어로 여러 데이터를 동시에 처리하는 명령어 세트로, 벡터 연산과 같은 병렬 처리를 효율적으로 할 수 있습니다.",
    "categoryId": 1
  },
  {
    "question": "멀티코어 프로세서에서의 공유 메모리 문제를 해결하는 방법은 무엇인가요?",
    "answer": "락(lock), 세마포어(semaphore), 뮤텍스(mutex)와 같은 동기화 메커니즘을 사용하여 공유 메모리 접근 문제를 해결합니다.",
    "categoryId": 1
  },
  {
    "question": "비휘발성 메모리와 휘발성 메모리의 차이점은 무엇인가요?",
    "answer": "휘발성 메모리는 전원이 꺼지면 데이터가 사라지지만, 비휘발성 메모리는 전원이 꺼져도 데이터를 유지합니다.",
    "categoryId": 1
  },
  {
    "question": "메모리 접근 시간이 중요한 이유는 무엇인가요?",
    "answer": "메모리 접근 시간은 CPU가 데이터를 읽고 쓰는 속도에 영향을 미치며, 짧은 접근 시간은 시스템 성능 향상에 기여합니다.",
    "categoryId": 1
  },
  {
    "question": "CPU 스케줄링에서 선점형과 비선점형 스케줄링의 차이점은 무엇인가요?",
    "answer": "선점형 스케줄링은 한 프로세스가 실행 중일 때 다른 프로세스가 강제로 CPU를 가져갈 수 있고, 비선점형은 현재 프로세스가 끝날 때까지 CPU를 양보하지 않습니다.",
    "categoryId": 1
  },
  {
    "question": "CPU 스케줄링에서 라운드 로빈(Round Robin) 알고리즘은 무엇인가요?",
    "answer": "라운드 로빈은 각 프로세스에 동일한 시간을 할당하여 순차적으로 CPU를 할당하는 선점형 스케줄링 알고리즘입니다.",
    "categoryId": 1
  },
  {
    "question": "CPU와 GPU의 차이점은 무엇인가요?",
    "answer": "CPU는 범용 프로세서로 다양한 작업을 처리할 수 있지만, GPU는 그래픽 및 병렬 처리를 위해 설계된 특화된 프로세서입니다.",
    "categoryId": 1
  },
  {
    "question": "DMA(Direct Memory Access)의 장점은 무엇인가요?",
    "answer": "DMA는 CPU 개입 없이 메모리와 I/O 장치 간 데이터를 직접 전송할 수 있어 CPU 부담을 줄이고 성능을 향상시킵니다.",
    "categoryId": 1
  },
  {
    "question": "스레드와 프로세스의 차이점은 무엇인가요?",
    "answer": "프로세스는 독립적인 실행 단위이고, 스레드는 프로세스 내에서 실행되는 작은 작업 단위로, 같은 메모리 공간을 공유합니다.",
    "categoryId": 1
  },
  {
    "question": "멀티스레딩(Multithreading)이 중요한 이유는 무엇인가요?",
    "answer": "멀티스레딩은 여러 스레드가 동시에 실행되도록 하여 프로그램의 병렬 처리를 가능하게 하며, CPU 사용률을 극대화합니다.",
    "categoryId": 1
  },
  {
    "question": "인터럽트(Interrupt)란 무엇인가요?",
    "answer": "인터럽트는 CPU가 프로그램 실행을 중단하고 특정 작업을 우선 처리하도록 요청하는 신호입니다.",
    "categoryId": 1
  },
  {
    "question": "인터럽트는 실시간 시스템에서 왜 중요한가요?",
    "answer": "실시간 시스템에서 인터럽트는 우선 순위가 높은 작업을 즉시 처리할 수 있도록 하여 시스템의 안정성과 신속성을 보장합니다.",
    "categoryId": 1
  },
  {
    "question": "버스 아키텍처에서 병목 현상이 발생하는 이유는 무엇인가요?",
    "answer": "CPU, 메모리, I/O 장치가 모두 하나의 버스를 공유하므로 동시에 여러 장치가 버스를 사용할 때 충돌이 발생하여 병목이 생깁니다.",
    "categoryId": 1
  },
  {
    "question": "버스 병목 현상을 해결하는 방법은 무엇인가요?",
    "answer": "멀티플 버스 아키텍처 또는 고속 인터커넥트를 사용하여 여러 장치가 동시에 데이터를 전송할 수 있도록 하면 병목 현상을 해결할 수 있습니다.",
    "categoryId": 1
  },
  {
    "question": "PCIe(Peripheral Component Interconnect Express)의 주요 기능은 무엇인가요?",
    "answer": "PCIe는 고속 직렬 인터페이스로, 컴퓨터의 마더보드와 외부 장치 간 빠른 데이터 전송을 가능하게 합니다.",
    "categoryId": 1
  },
  {
    "question": "스레드 간의 경쟁 상태(Race Condition)란 무엇인가요?",
    "answer": "경쟁 상태는 여러 스레드가 공유 자원을 동시에 접근할 때 발생하는 문제로, 예기치 않은 결과를 초래할 수 있습니다.",
    "categoryId": 1
  },
  {
    "question": "경쟁 상태를 방지하는 방법은 무엇인가요?",
    "answer": "락, 세마포어, 뮤텍스와 같은 동기화 기법을 사용하여 스레드 간에 공유 자원에 대한 접근을 제어합니다.",
    "categoryId": 1
  },
  {
    "question": "OSI 7계층이란 무엇인가요?",
    "answer": "OSI 7계층은 네트워크 통신을 계층화하여 설명하는 모델로, 물리 계층, 데이터 링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층으로 구성됩니다.",
    "categoryId": 2
  },
  {
    "question": "TCP와 UDP의 차이점은 무엇인가요?",
    "answer": "TCP는 연결 지향형 프로토콜로 신뢰성 있는 데이터 전송을 보장하고, UDP는 비연결형으로 빠르지만 데이터 전송의 신뢰성은 보장하지 않습니다.",
    "categoryId": 2
  },
  {
    "question": "IP 주소란 무엇인가요?",
    "answer": "IP 주소는 네트워크 상의 장치를 식별하는 고유한 주소입니다. IPv4는 32비트 주소 체계, IPv6는 128비트 주소 체계를 사용합니다.",
    "categoryId": 2
  },
  {
    "question": "서브넷 마스크란 무엇인가요?",
    "answer": "서브넷 마스크는 IP 주소를 네트워크 주소와 호스트 주소로 구분하는 데 사용되며, 네트워크의 크기를 정의합니다.",
    "categoryId": 2
  },
  {
    "question": "DNS(Domain Name System)의 역할은 무엇인가요?",
    "answer": "DNS는 도메인 이름을 IP 주소로 변환해 주는 시스템으로, 사람이 읽을 수 있는 도메인 주소를 컴퓨터가 이해할 수 있는 IP 주소로 변환합니다.",
    "categoryId": 2
  },
  {
    "question": "DHCP(Dynamic Host Configuration Protocol)란 무엇인가요?",
    "answer": "DHCP는 네트워크 상의 장치에 동적으로 IP 주소를 자동으로 할당하는 프로토콜입니다.",
    "categoryId": 2
  },
  {
    "question": "MAC 주소란 무엇인가요?",
    "answer": "MAC 주소는 네트워크 인터페이스에 할당된 고유 식별자로, LAN에서 장치를 식별하는 데 사용됩니다.",
    "categoryId": 2
  },
  {
    "question": "패킷 스위칭(Packet Switching)이란 무엇인가요?",
    "answer": "패킷 스위칭은 데이터를 작은 패킷 단위로 나누어 네트워크를 통해 전송하는 방식으로, 인터넷에서 주로 사용됩니다.",
    "categoryId": 2
  },
  {
    "question": "라우터와 스위치의 차이점은 무엇인가요?",
    "answer": "라우터는 네트워크 간 데이터를 전달하며, 스위치는 동일 네트워크 내에서 데이터를 전달하는 장치입니다.",
    "categoryId": 2
  },
  {
    "question": "방화벽(Firewall)의 역할은 무엇인가요?",
    "answer": "방화벽은 네트워크 보안을 위해 허가되지 않은 트래픽을 차단하고, 허가된 트래픽만 통과시키는 역할을 합니다.",
    "categoryId": 2
  },
  {
    "question": "VPN(Virtual Private Network)이란 무엇인가요?",
    "answer": "VPN은 공용 네트워크에서 개인 네트워크를 구성하여 암호화된 안전한 통신을 제공하는 기술입니다.",
    "categoryId": 2
  },
  {
    "question": "TCP의 3-way handshake란 무엇인가요?",
    "answer": "TCP의 3-way handshake는 클라이언트와 서버 간의 연결을 설정하기 위해 SYN, SYN-ACK, ACK 패킷을 주고받는 과정입니다.",
    "categoryId": 2
  },
  {
    "question": "Ping 명령어의 역할은 무엇인가요?",
    "answer": "Ping은 네트워크 장치 간의 연결 상태를 확인하고, 네트워크 지연 시간을 측정하는 데 사용되는 명령어입니다.",
    "categoryId": 2
  },
  {
    "question": "Traceroute 명령어란 무엇인가요?",
    "answer": "Traceroute는 패킷이 목적지까지 가는 경로를 추적하여 중간에 거치는 모든 네트워크 장치의 정보를 보여주는 명령어입니다.",
    "categoryId": 2
  },
  {
    "question": "HTTP와 HTTPS의 차이점은 무엇인가요?",
    "answer": "HTTP는 데이터를 암호화하지 않는 프로토콜이고, HTTPS는 SSL/TLS를 사용해 데이터를 암호화하여 전송하는 보안 프로토콜입니다.",
    "categoryId": 2
  },
  {
    "question": "네트워크에서 포트(Port)란 무엇인가요?",
    "answer": "포트는 네트워크에서 프로세스 간의 통신을 구분하기 위한 숫자 체계로, 각 애플리케이션이 고유한 포트 번호를 사용해 통신합니다.",
    "categoryId": 2
  },
  {
    "question": "NAT(Network Address Translation)란 무엇인가요?",
    "answer": "NAT는 사설 IP 주소를 공인 IP 주소로 변환하여 인터넷과 통신할 수 있게 하는 기술입니다.",
    "categoryId": 2
  },
  {
    "question": "데이터 패킷(Data Packet)이란 무엇인가요?",
    "answer": "데이터 패킷은 네트워크를 통해 전송되는 데이터의 기본 단위로, 헤더와 페이로드로 구성됩니다.",
    "categoryId": 2
  },
  {
    "question": "ICMP(Internet Control Message Protocol)란 무엇인가요?",
    "answer": "ICMP는 네트워크 장비 간의 오류 메시지 전달과 진단 기능을 제공하는 프로토콜로, 주로 Ping 명령어에서 사용됩니다.",
    "categoryId": 2
  },
  {
    "question": "네트워크 지연(Latency)이란 무엇인가요?",
    "answer": "네트워크 지연은 데이터를 전송할 때 발생하는 시간 지연을 의미하며, 낮을수록 네트워크 성능이 좋습니다.",
    "categoryId": 2
  },
  {
    "question": "대역폭(Bandwidth)이란 무엇인가요?",
    "answer": "대역폭은 네트워크에서 주어진 시간 동안 전송할 수 있는 데이터 양을 나타내며, Mbps 또는 Gbps 단위로 측정됩니다.",
    "categoryId": 2
  },
  {
    "question": "QoS(Quality of Service)란 무엇인가요?",
    "answer": "QoS는 네트워크에서 트래픽의 우선순위를 정해 특정 데이터 전송의 품질을 보장하는 기술입니다.",
    "categoryId": 2
  },
  {
    "question": "애니캐스트(Anycast)란 무엇인가요?",
    "answer": "애니캐스트는 동일한 IP 주소를 여러 위치에 할당해 가장 가까운 위치의 서버로 트래픽을 라우팅하는 방식입니다.",
    "categoryId": 2
  },
  {
    "question": "브로드캐스트(Broadcast)란 무엇인가요?",
    "answer": "브로드캐스트는 네트워크 상에서 특정 호스트가 네트워크 내 모든 장치로 데이터를 전송하는 방식입니다.",
    "categoryId": 2
  },
  {
    "question": "ARP(Address Resolution Protocol)란 무엇인가요?",
    "answer": "ARP는 IP 주소를 기반으로 네트워크 장치의 MAC 주소를 알아내기 위해 사용되는 프로토콜입니다.",
    "categoryId": 2
  },
  {
    "question": "라우팅 프로토콜이란 무엇인가요?",
    "answer": "라우팅 프로토콜은 네트워크 상에서 데이터를 전달하기 위한 최적의 경로를 결정하는 데 사용되는 프로토콜입니다.",
    "categoryId": 2
  },
  {
    "question": "STP(Spanning Tree Protocol)란 무엇인가요?",
    "answer": "STP는 이더넷 네트워크에서 루프를 방지하기 위해 네트워크 경로를 동적으로 조정하는 프로토콜입니다.",
    "categoryId": 2
  },
  {
    "question": "패킷 손실(Packet Loss)이란 무엇인가요?",
    "answer": "패킷 손실은 네트워크에서 전송 중인 데이터 패킷이 손실되어 목적지에 도달하지 못하는 현상을 말합니다.",
    "categoryId": 2
  },
  {
    "question": "로드 밸런싱이란 무엇인가요?",
    "answer": "로드 밸런싱은 네트워크 트래픽을 여러 서버에 분산시켜 각 서버의 부하를 줄이고 시스템의 성능과 안정성을 높이는 기술입니다.",
    "categoryId": 2
  },
  {
    "question": "HTTP 상태 코드 404는 무엇을 의미하나요?",
    "answer": "HTTP 404 상태 코드는 클라이언트가 요청한 리소스를 서버에서 찾을 수 없음을 나타냅니다.",
    "categoryId": 2
  },
  {
    "question": "네트워크 프로토콜이란 무엇인가요?",
    "answer": "네트워크 프로토콜은 네트워크 상에서 데이터 전송을 위한 규칙과 절차를 정의하는 표준입니다.",
    "categoryId": 2
  },
  {
    "question": "MTU(Maximum Transmission Unit)란 무엇인가요?",
    "answer": "MTU는 네트워크 인터페이스에서 전송할 수 있는 최대 패킷 크기로, MTU 값이 클수록 전송 효율이 높아집니다.",
    "categoryId": 2
  },
  {
    "question": "네트워크 토폴로지(Network Topology)란 무엇인가요?",
    "answer": "네트워크 토폴로지는 네트워크 장치들이 물리적 또는 논리적으로 어떻게 연결되어 있는지를 나타냅니다. 스타, 버스, 링 등이 대표적인 형태입니다.",
    "categoryId": 2
  },
  {
    "question": "유니캐스트(Unicast)란 무엇인가요?",
    "answer": "유니캐스트는 하나의 송신자가 하나의 수신자에게 데이터를 전송하는 방식입니다.",
    "categoryId": 2
  },
  {
    "question": "포트 포워딩(Port Forwarding)이란 무엇인가요?",
    "answer": "포트 포워딩은 외부 네트워크에서 특정 포트로 들어오는 트래픽을 내부 네트워크의 특정 장치로 전달하는 기술입니다.",
    "categoryId": 2
  },
  {
    "question": "프로토콜 스택이란 무엇인가요?",
    "answer": "프로토콜 스택은 네트워크 통신을 처리하기 위해 계층화된 네트워크 프로토콜들의 집합입니다. 예: TCP/IP 스택.",
    "categoryId": 2
  },
  {
    "question": "패킷 필터링(Packet Filtering)이란 무엇인가요?",
    "answer": "패킷 필터링은 패킷의 헤더 정보를 분석하여 허용 또는 차단 여부를 결정하는 방식으로, 주로 방화벽에서 사용됩니다.",
    "categoryId": 2
  },
  {
    "question": "VLAN(Virtual Local Area Network)이란 무엇인가요?",
    "answer": "VLAN은 물리적인 네트워크 구조에 상관없이 논리적으로 구분된 네트워크로, 트래픽을 분리하여 네트워크 성능과 보안을 향상시킵니다.",
    "categoryId": 2
  },
  {
    "question": "네트워크 어댑터(Network Adapter)란 무엇인가요?",
    "answer": "네트워크 어댑터는 컴퓨터가 네트워크에 연결되도록 해주는 하드웨어 장치로, NIC(Network Interface Card)라고도 합니다.",
    "categoryId": 2
  },
  {
    "question": "SLA(Service Level Agreement)란 무엇인가요?",
    "answer": "SLA는 서비스 제공자와 사용자 간의 서비스 품질 수준을 보장하기 위한 계약으로, 가동 시간, 성능, 응답 시간을 포함할 수 있습니다.",
    "categoryId": 2
  },
  {
    "question": "비대칭 라우팅(Asymmetric Routing)이란 무엇인가요?",
    "answer": "비대칭 라우팅은 데이터가 전송될 때 출발지에서 목적지로 가는 경로와 목적지에서 출발지로 돌아오는 경로가 다른 라우팅 방식을 의미합니다.",
    "categoryId": 2
  },
  {
    "question": "TTL(Time To Live)란 무엇인가요?",
    "answer": "TTL은 패킷이 네트워크를 통해 얼마나 오래 전달될 수 있는지를 나타내는 값으로, TTL이 0이 되면 패킷은 폐기됩니다.",
    "categoryId": 2
  },
  {
    "question": "네트워크 스니핑(Network Sniffing)이란 무엇인가요?",
    "answer": "네트워크 스니핑은 네트워크 상의 패킷을 가로채어 분석하는 기술로, 주로 네트워크 문제 해결 및 보안 위협 탐지에 사용됩니다.",
    "categoryId": 2
  },
  {
    "question": "IPv4와 IPv6의 차이점은 무엇인가요?",
    "answer": "IPv4는 32비트 주소 체계를 사용하여 약 43억 개의 IP 주소를 제공하지만, IPv6는 128비트 주소 체계를 사용해 더 많은 IP 주소를 제공합니다.",
    "categoryId": 2
  },
  {
    "question": "라우팅 테이블이란 무엇인가요?",
    "answer": "라우팅 테이블은 네트워크 장치가 데이터 패킷을 어디로 보낼지 결정하기 위한 정보를 담고 있는 테이블입니다.",
    "categoryId": 2
  },
  {
    "question": "멀티캐스트(Multicast)란 무엇인가요?",
    "answer": "멀티캐스트는 하나의 송신자가 네트워크 상의 특정 그룹에 속한 다수의 수신자에게 동시에 데이터를 전송하는 방식입니다.",
    "categoryId": 2
  },
  {
    "question": "3-way handshake 과정에서 SYN 플러드 공격이란 무엇인가요?",
    "answer": "SYN 플러드 공격은 TCP 3-way handshake 과정에서 다량의 SYN 요청을 보내 서버 자원을 고갈시키는 DoS 공격 방식입니다.",
    "categoryId": 2
  },
  {
    "question": "라우팅(Routing)과 브리징(Bridging)의 차이점은 무엇인가요?",
    "answer": "라우팅은 네트워크 간 트래픽을 전달하고, 브리징은 같은 네트워크 세그먼트 내에서 트래픽을 전달합니다.",
    "categoryId": 2
  },
  {
    "question": "네트워크 주소 할당 방식 중 정적 IP와 동적 IP의 차이점은 무엇인가요?",
    "answer": "정적 IP는 고정된 IP 주소를 장치에 할당하는 방식이고, 동적 IP는 DHCP를 통해 필요할 때마다 자동으로 할당되는 IP 주소입니다.",
    "categoryId": 2
  },
  {
    "question": "DMZ(Demilitarized Zone)란 무엇인가요?",
    "answer": "DMZ는 외부 네트워크와 내부 네트워크 사이에 위치한 중간 구역으로, 외부에서 접근 가능한 서버를 배치하여 보안을 강화합니다.",
    "categoryId": 2
  },
  {
    "question": "보안 그룹(Security Group)이란 무엇인가요?",
    "answer": "보안 그룹은 클라우드 환경에서 인스턴스 간 네트워크 트래픽을 제어하기 위해 사용되는 가상 방화벽입니다.",
    "categoryId": 2
  },
  {
    "question": "대칭키 암호화와 비대칭키 암호화의 차이점은 무엇인가요?",
    "answer": "대칭키 암호화는 하나의 키로 암호화와 복호화를 모두 수행하는 방식이고, 비대칭키 암호화는 공개키로 암호화하고 개인키로 복호화하는 방식입니다.",
    "categoryId": 2
  },
  {
    "question": "포트 스캐닝(Port Scanning)이란 무엇인가요?",
    "answer": "포트 스캐닝은 시스템에서 열려 있는 포트를 확인하여 보안 취약점을 찾기 위한 방법으로, 보안 위협 탐지 및 공격 준비에 사용될 수 있습니다.",
    "categoryId": 2
  },
  {
    "question": "RARP(Reverse Address Resolution Protocol)이란 무엇인가요?",
    "answer": "RARP는 MAC 주소를 기반으로 해당 장치의 IP 주소를 알아내는 프로토콜입니다.",
    "categoryId": 2
  },
  {
    "question": "ISP(Internet Service Provider)란 무엇인가요?",
    "answer": "ISP는 인터넷에 접속할 수 있는 서비스를 제공하는 회사로, 개인 및 기업에게 인터넷 연결 서비스를 제공합니다.",
    "categoryId": 2
  },
  {
    "question": "프로토콜에서 상태 저장(stateful)과 상태 비저장(stateless)의 차이는 무엇인가요?",
    "answer": "상태 저장 프로토콜은 이전의 통신 상태를 기억하고 유지하며, 상태 비저장 프로토콜은 각 요청을 독립적으로 처리하고 이전 통신 정보를 기억하지 않습니다.",
    "categoryId": 2
  },
  {
    "question": "SSL/TLS란 무엇인가요?",
    "answer": "SSL/TLS는 네트워크 상에서 데이터 전송을 암호화하여 보안을 강화하는 프로토콜로, HTTPS에서 사용됩니다.",
    "categoryId": 2
  },
  {
    "question": "트래픽 셰이핑(Traffic Shaping)이란 무엇인가요?",
    "answer": "트래픽 셰이핑은 네트워크 트래픽을 일정하게 조절하여 네트워크 대역폭을 효율적으로 사용하고, 혼잡을 방지하는 기술입니다.",
    "categoryId": 2
  },
  {
    "question": "IGP(Interior Gateway Protocol)란 무엇인가요?",
    "answer": "IGP는 동일 자치 시스템 내에서 사용되는 라우팅 프로토콜로, 대표적인 예로 OSPF와 RIP가 있습니다.",
    "categoryId": 2
  },
  {
    "question": "OSPF(Open Shortest Path First)란 무엇인가요?",
    "answer": "OSPF는 링크 상태 라우팅 프로토콜로, 네트워크에서 최단 경로를 찾아 데이터를 전달하는 데 사용됩니다.",
    "categoryId": 2
  },
  {
    "question": "비동기 전송 모드(ATM)란 무엇인가요?",
    "answer": "ATM은 셀(Cell) 단위로 데이터를 전송하는 고속 전송 프로토콜로, 음성, 영상, 데이터를 모두 전송할 수 있습니다.",
    "categoryId": 2
  },
  {
    "question": "CDN(Content Delivery Network)이란 무엇인가요?",
    "answer": "CDN은 전 세계에 분산된 서버를 통해 사용자와 가까운 서버에서 콘텐츠를 제공하여 웹사이트 로딩 속도를 향상시키는 네트워크입니다.",
    "categoryId": 2
  },
  {
    "question": "프로토콜에서 핸드셰이크(Handshake)란 무엇인가요?",
    "answer": "핸드셰이크는 네트워크 통신을 시작하기 전에 두 장치 간 연결 설정을 위한 과정으로, TCP의 3-way handshake가 대표적인 예입니다.",
    "categoryId": 2
  },
  {
    "question": "네트워크 캐시(Network Cache)란 무엇인가요?",
    "answer": "네트워크 캐시는 자주 요청되는 데이터를 네트워크 장치에 저장하여 트래픽을 줄이고 응답 시간을 단축시키는 기술입니다.",
    "categoryId": 2
  },
  {
    "question": "멀티플렉싱(Multiplexing)이란 무엇인가요?",
    "answer": "멀티플렉싱은 여러 개의 신호를 하나의 통신 채널을 통해 전송하는 기술로, 대역폭을 효율적으로 사용할 수 있습니다.",
    "categoryId": 2
  },
  {
    "question": "다중 경로 라우팅(Multipath Routing)이란 무엇인가요?",
    "answer": "다중 경로 라우팅은 여러 경로를 통해 데이터를 전달하여 네트워크의 신뢰성과 성능을 높이는 라우팅 방식입니다.",
    "categoryId": 2
  },
  {
    "question": "운영체제란 무엇인가요?",
    "answer": "운영체제는 하드웨어와 소프트웨어 자원을 관리하고, 컴퓨터 시스템의 사용자와 하드웨어 간의 인터페이스를 제공하는 소프트웨어입니다.",
    "categoryId": 3
  },
  {
    "question": "프로세스와 스레드의 차이점은 무엇인가요?",
    "answer": "프로세스는 실행 중인 프로그램을 의미하며, 스레드는 프로세스 내에서 실행되는 작은 작업 단위입니다. 스레드는 같은 프로세스 내에서 자원을 공유합니다.",
    "categoryId": 3
  },
  {
    "question": "멀티프로세싱과 멀티스레딩의 차이점은 무엇인가요?",
    "answer": "멀티프로세싱은 여러 프로세서를 사용하여 여러 프로세스를 동시에 실행하는 방식이고, 멀티스레딩은 하나의 프로세스 내에서 여러 스레드를 실행하는 방식입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 메모리 관리의 역할은 무엇인가요?",
    "answer": "운영체제는 메모리를 효율적으로 관리하여 각 프로그램이 필요한 메모리를 할당받고, 메모리 간 충돌이 발생하지 않도록 보호합니다.",
    "categoryId": 3
  },
  {
    "question": "가상 메모리란 무엇인가요?",
    "answer": "가상 메모리는 물리적 메모리보다 큰 메모리 공간을 사용할 수 있도록 하는 기술로, 디스크의 일부를 메모리처럼 사용하는 방식입니다.",
    "categoryId": 3
  },
  {
    "question": "페이징(Paging)이란 무엇인가요?",
    "answer": "페이징은 메모리를 동일한 크기의 페이지로 나누어 관리하는 기법으로, 가상 메모리의 일부를 물리 메모리에 적재하여 사용합니다.",
    "categoryId": 3
  },
  {
    "question": "스케줄러란 무엇인가요?",
    "answer": "스케줄러는 CPU 사용을 효율적으로 관리하기 위해 프로세스나 스레드에 CPU 시간을 할당하는 역할을 합니다.",
    "categoryId": 3
  },
  {
    "question": "선점형 스케줄링과 비선점형 스케줄링의 차이점은 무엇인가요?",
    "answer": "선점형 스케줄링은 실행 중인 프로세스를 중단하고 다른 프로세스를 실행할 수 있는 방식이고, 비선점형은 프로세스가 자발적으로 CPU를 양보할 때까지 실행되는 방식입니다.",
    "categoryId": 3
  },
  {
    "question": "교착 상태(Deadlock)란 무엇인가요?",
    "answer": "교착 상태는 두 개 이상의 프로세스가 서로 상대방이 점유한 자원을 기다리며 무한정 대기하는 상황을 의미합니다.",
    "categoryId": 3
  },
  {
    "question": "교착 상태를 해결하는 방법은 무엇인가요?",
    "answer": "교착 상태를 해결하는 방법으로는 예방, 회피, 탐지, 복구 방법이 있으며, 자원 할당 그래프나 은행원 알고리즘을 사용해 회피할 수 있습니다.",
    "categoryId": 3
  },
  {
    "question": "문맥 교환(Context Switch)이란 무엇인가요?",
    "answer": "문맥 교환은 CPU가 현재 실행 중인 프로세스의 상태를 저장하고, 다음 프로세스의 상태를 불러와 실행하는 과정입니다.",
    "categoryId": 3
  },
  {
    "question": "파일 시스템이란 무엇인가요?",
    "answer": "파일 시스템은 데이터의 저장 및 관리를 담당하는 구조로, 파일과 디렉토리를 구성하고 파일의 읽기, 쓰기, 삭제를 처리합니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 인터럽트란 무엇인가요?",
    "answer": "인터럽트는 프로세스 실행 중에 예기치 않은 사건이 발생할 때, 현재 작업을 중단하고 운영체제가 해당 사건을 처리하도록 하는 신호입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제의 커널(Kernel)이란 무엇인가요?",
    "answer": "커널은 운영체제의 핵심 부분으로, 하드웨어 자원을 관리하고 시스템의 프로세스, 메모리, 파일 시스템, I/O를 제어합니다.",
    "categoryId": 3
  },
  {
    "question": "멀티태스킹(Multitasking)이란 무엇인가요?",
    "answer": "멀티태스킹은 여러 프로세스가 동시에 실행되는 것처럼 보이도록 CPU 시간을 분할하여 처리하는 방식입니다.",
    "categoryId": 3
  },
  {
    "question": "스와핑(Swapping)이란 무엇인가요?",
    "answer": "스와핑은 메모리에서 사용하지 않는 프로세스를 디스크로 이동시키고, 다시 필요할 때 메모리로 불러오는 과정입니다.",
    "categoryId": 3
  },
  {
    "question": "I/O 바운드와 CPU 바운드의 차이점은 무엇인가요?",
    "answer": "I/O 바운드는 입력/출력 작업에 의해 제한되는 프로세스이고, CPU 바운드는 CPU 연산에 의해 제한되는 프로세스입니다.",
    "categoryId": 3
  },
  {
    "question": "세마포어(Semaphore)란 무엇인가요?",
    "answer": "세마포어는 멀티프로세싱 환경에서 여러 프로세스가 공유 자원에 접근할 때 동기화를 제어하는 도구입니다.",
    "categoryId": 3
  },
  {
    "question": "뮤텍스(Mutex)와 세마포어의 차이점은 무엇인가요?",
    "answer": "뮤텍스는 한 번에 하나의 프로세스만 공유 자원에 접근할 수 있도록 하고, 세마포어는 여러 프로세스가 일정 수만큼 자원에 접근할 수 있도록 허용합니다.",
    "categoryId": 3
  },
  {
    "question": "캐시 메모리(Cache Memory)의 역할은 무엇인가요?",
    "answer": "캐시 메모리는 CPU와 메인 메모리 사이에 위치하여 자주 사용되는 데이터를 임시 저장해 CPU 접근 속도를 높여주는 메모리입니다.",
    "categoryId": 3
  },
  {
    "question": "페이징과 세그먼테이션(Segmentation)의 차이점은 무엇인가요?",
    "answer": "페이징은 메모리를 고정 크기의 페이지로 나누고, 세그먼테이션은 논리적 크기에 따라 메모리를 분할하는 방식입니다.",
    "categoryId": 3
  },
  {
    "question": "스레싱(Thrashing)이란 무엇인가요?",
    "answer": "스레싱은 프로세스들이 페이지 교체 작업에 너무 많은 시간을 소모해 실제 작업이 거의 진행되지 않는 현상입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 힙(Heap)과 스택(Stack)의 차이점은 무엇인가요?",
    "answer": "힙은 동적으로 할당되는 메모리 영역이고, 스택은 함수 호출 시 자동으로 할당되는 고정 크기의 메모리 영역입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 부팅(Booting)이란 무엇인가요?",
    "answer": "부팅은 컴퓨터가 전원을 켠 후 운영체제를 메모리에 적재하여 시스템이 동작할 수 있도록 하는 과정입니다.",
    "categoryId": 3
  },
  {
    "question": "시스템 콜(System Call)이란 무엇인가요?",
    "answer": "시스템 콜은 프로그램이 운영체제의 서비스를 요청하는 인터페이스로, 하드웨어 자원에 접근할 때 사용됩니다.",
    "categoryId": 3
  },
  {
    "question": "가상 메모리에서 페이지 폴트(Page Fault)란 무엇인가요?",
    "answer": "페이지 폴트는 프로세스가 필요한 메모리 페이지가 물리 메모리에 없을 때 발생하며, 운영체제가 해당 페이지를 디스크에서 메모리로 가져옵니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 FIFO 스케줄링이란 무엇인가요?",
    "answer": "FIFO(First In, First Out) 스케줄링은 먼저 도착한 프로세스가 먼저 실행되는 스케줄링 알고리즘입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 라운드 로빈(Round Robin) 스케줄링이란 무엇인가요?",
    "answer": "라운드 로빈 스케줄링은 각 프로세스에 동일한 시간 슬라이스를 할당하고, 순서대로 CPU를 할당하는 선점형 스케줄링 방식입니다.",
    "categoryId": 3
  },
  {
    "question": "SJF(Shortest Job First) 스케줄링이란 무엇인가요?",
    "answer": "SJF 스케줄링은 실행 시간이 가장 짧은 작업을 우선적으로 실행하는 스케줄링 알고리즘으로, 평균 대기 시간을 최소화합니다.",
    "categoryId": 3
  },
  {
    "question": "우선순위 스케줄링이란 무엇인가요?",
    "answer": "우선순위 스케줄링은 각 프로세스에 우선순위를 부여하고, 우선순위가 높은 프로세스가 먼저 실행되는 스케줄링 방식입니다.",
    "categoryId": 3
  },
  {
    "question": "멀티레벨 큐(Multilevel Queue) 스케줄링이란 무엇인가요?",
    "answer": "멀티레벨 큐 스케줄링은 프로세스를 여러 큐로 나누어 각 큐마다 다른 스케줄링 알고리즘을 적용하는 방식입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 선점(Preemption)이란 무엇인가요?",
    "answer": "선점은 실행 중인 프로세스가 CPU를 점유하고 있는 도중, 더 높은 우선순위의 프로세스가 CPU를 차지할 수 있도록 중단하는 방식입니다.",
    "categoryId": 3
  },
  {
    "question": "비선점(Non-preemptive)이란 무엇인가요?",
    "answer": "비선점은 실행 중인 프로세스가 자발적으로 CPU를 양보할 때까지 계속해서 실행되는 방식으로, 중간에 다른 프로세스가 CPU를 차지할 수 없습니다.",
    "categoryId": 3
  },
  {
    "question": "LRU(Least Recently Used) 페이지 교체 알고리즘이란 무엇인가요?",
    "answer": "LRU 페이지 교체 알고리즘은 가장 최근에 사용되지 않은 페이지를 우선적으로 교체하는 방식으로, 자주 사용된 페이지를 메모리에 유지합니다.",
    "categoryId": 3
  },
  {
    "question": "FIFO 페이지 교체 알고리즘이란 무엇인가요?",
    "answer": "FIFO 페이지 교체 알고리즘은 메모리에 먼저 들어온 페이지를 먼저 내보내는 방식으로, 페이지 교체 시 순차적으로 교체합니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 페이지 교체란 무엇인가요?",
    "answer": "페이지 교체는 물리 메모리가 가득 찼을 때 새로운 페이지를 메모리에 적재하기 위해 기존의 페이지를 디스크로 내보내는 작업입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 메모리 단편화(Fragmentation)란 무엇인가요?",
    "answer": "메모리 단편화는 메모리 할당 및 해제 과정에서 생기는 사용되지 않는 작은 메모리 조각으로, 내부 단편화와 외부 단편화로 구분됩니다.",
    "categoryId": 3
  },
  {
    "question": "내부 단편화(Internal Fragmentation)란 무엇인가요?",
    "answer": "내부 단편화는 프로세스에 할당된 메모리 공간 중 실제 사용하지 않는 남은 공간을 의미합니다.",
    "categoryId": 3
  },
  {
    "question": "외부 단편화(External Fragmentation)란 무엇인가요?",
    "answer": "외부 단편화는 메모리의 빈 공간들이 여러 곳에 흩어져 있어 프로세스가 사용할 수 없게 되는 현상을 의미합니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 스레드 풀(Thread Pool)이란 무엇인가요?",
    "answer": "스레드 풀은 작업 요청이 들어오면 미리 생성된 스레드를 재사용하여 새로운 스레드를 생성하는 비용을 절감하는 방식입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 사용자 수준 스레드(User-Level Thread)와 커널 수준 스레드(Kernel-Level Thread)의 차이점은 무엇인가요?",
    "answer": "사용자 수준 스레드는 커널의 개입 없이 사용자 공간에서 관리되며, 커널 수준 스레드는 운영체제 커널에서 관리됩니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 임계 구역(Critical Section)이란 무엇인가요?",
    "answer": "임계 구역은 두 개 이상의 프로세스나 스레드가 동시에 접근하면 안 되는 공유 자원에 접근하는 코드 영역을 의미합니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 동기화(Synchronization)란 무엇인가요?",
    "answer": "동기화는 여러 프로세스나 스레드가 서로 상호작용하면서 데이터를 일관성 있게 접근할 수 있도록 하는 방법입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 메모리 매핑(Memory Mapping)이란 무엇인가요?",
    "answer": "메모리 매핑은 파일이나 장치의 내용을 프로세스의 가상 메모리에 매핑하여 해당 내용을 메모리처럼 사용할 수 있도록 하는 방법입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 부하 분산(Load Balancing)이란 무엇인가요?",
    "answer": "부하 분산은 시스템 자원의 부하를 여러 프로세스에 골고루 분배하여 시스템 성능을 최적화하는 기법입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 시간 분할 시스템(Time Sharing System)이란 무엇인가요?",
    "answer": "시간 분할 시스템은 여러 사용자가 동시에 시스템을 사용할 수 있도록 CPU 시간을 짧게 분할하여 각 사용자에게 순서대로 할당하는 운영체제입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 리눅스와 윈도우의 주요 차이점은 무엇인가요?",
    "answer": "리눅스는 오픈 소스 운영체제이고, 윈도우는 상용 운영체제로, 파일 시스템, 커널 구조, 사용자 인터페이스 등이 다릅니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 데드락 예방 방법은 무엇인가요?",
    "answer": "데드락 예방 방법으로는 자원의 순환 대기 방지, 자원의 점유와 대기 방지, 비선점적 자원의 최소화가 있습니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 프로세스 상태 전이(Process State Transition)란 무엇인가요?",
    "answer": "프로세스 상태 전이는 실행, 대기, 준비, 종료 등의 상태 변화 과정을 의미하며, 프로세스의 실행 단계에 따라 상태가 전이됩니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 하드 리얼타임 시스템과 소프트 리얼타임 시스템의 차이점은 무엇인가요?",
    "answer": "하드 리얼타임 시스템은 일정한 시간 내에 작업이 반드시 완료되어야 하고, 소프트 리얼타임 시스템은 시간이 지나도 일정 범위 내에서 작업을 수행할 수 있습니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 페이지 크기(Page Size)를 결정하는 기준은 무엇인가요?",
    "answer": "페이지 크기는 시스템의 메모리 크기와 프로세스의 메모리 사용 패턴을 고려하여 설정되며, 크기가 크면 페이지 수가 줄고, 작으면 내부 단편화가 줄어듭니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 인터럽트 벡터(Interrupt Vector)란 무엇인가요?",
    "answer": "인터럽트 벡터는 특정 인터럽트가 발생했을 때 해당 인터럽트 처리 루틴의 주소를 저장하는 테이블입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 직접 메모리 접근(DMA, Direct Memory Access)이란 무엇인가요?",
    "answer": "DMA는 CPU의 개입 없이 I/O 장치가 메모리에 직접 접근하여 데이터를 전송하는 방식으로, CPU의 부담을 줄여줍니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 부팅 시 일어나는 과정을 설명하세요.",
    "answer": "부팅 과정은 BIOS/UEFI가 하드웨어를 초기화하고, 부트로더가 운영체제를 메모리에 적재하여 실행하는 일련의 과정입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 핸들(Handle)이란 무엇인가요?",
    "answer": "핸들은 운영체제가 프로세스와 자원 간의 연결을 관리하기 위해 사용하는 추상적인 참조로, 파일, 메모리, 장치 등을 식별합니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 실시간 처리 시스템(Real-Time Operating System)이란 무엇인가요?",
    "answer": "실시간 처리 시스템은 주어진 시간 내에 작업을 반드시 완료해야 하는 시스템으로, 주로 산업 제어, 통신 시스템 등에 사용됩니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 프로세스 제어 블록(PCB)이란 무엇인가요?",
    "answer": "PCB는 운영체제가 각 프로세스의 상태, 메모리 정보, 레지스터 값 등을 저장하는 데이터 구조로, 프로세스 관리에 사용됩니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 포크(Fork)란 무엇인가요?",
    "answer": "포크는 운영체제에서 프로세스를 복제하여 새로운 프로세스를 생성하는 시스템 호출로, 부모 프로세스의 주소 공간을 복사합니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 좀비 프로세스(Zombie Process)란 무엇인가요?",
    "answer": "좀비 프로세스는 실행이 완료되었지만, 부모 프로세스가 종료 상태를 회수하지 않아 PCB가 여전히 남아 있는 프로세스입니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 스레드가 중요한 이유는 무엇인가요?",
    "answer": "스레드는 같은 프로세스 내에서 자원을 공유하면서 병렬 처리가 가능하므로, 자원 사용 효율을 높이고 성능을 개선할 수 있습니다.",
    "categoryId": 3
  },
  {
    "question": "운영체제에서 가상 메모리의 장점은 무엇인가요?",
    "answer": "가상 메모리는 실제 물리적 메모리 크기보다 더 큰 메모리 공간을 사용할 수 있게 하여 프로그램 실행의 효율성을 높여줍니다.",
    "categoryId": 3
  },
  {
    "question": "자료구조란 무엇인가요?",
    "answer": "자료구조는 데이터를 저장하고 조직화하는 방법으로, 효율적인 데이터 접근과 수정이 가능하도록 설계된 구조입니다.",
    "categoryId": 4
  },
  {
    "question": "배열(Array)과 링크드 리스트(Linked List)의 차이점은 무엇인가요?",
    "answer": "배열은 메모리상에 연속적으로 배치된 고정 크기의 데이터 집합이고, 링크드 리스트는 각 요소가 포인터로 연결된 동적 크기의 데이터 집합입니다.",
    "categoryId": 4
  },
  {
    "question": "스택(Stack)이란 무엇인가요?",
    "answer": "스택은 후입선출(LIFO) 방식으로 데이터를 저장하는 자료구조로, 마지막에 삽입된 데이터가 먼저 삭제됩니다.",
    "categoryId": 4
  },
  {
    "question": "큐(Queue)란 무엇인가요?",
    "answer": "큐는 선입선출(FIFO) 방식으로 데이터를 저장하는 자료구조로, 먼저 삽입된 데이터가 먼저 삭제됩니다.",
    "categoryId": 4
  },
  {
    "question": "링크드 리스트(Linked List)란 무엇인가요?",
    "answer": "링크드 리스트는 각 노드가 데이터와 다음 노드를 가리키는 포인터로 이루어진 연결 리스트로, 동적 크기 조절이 가능합니다.",
    "categoryId": 4
  },
  {
    "question": "단일 연결 리스트(Singly Linked List)와 이중 연결 리스트(Doubly Linked List)의 차이점은 무엇인가요?",
    "answer": "단일 연결 리스트는 각 노드가 다음 노드만 가리키고, 이중 연결 리스트는 각 노드가 이전 및 다음 노드를 가리킵니다.",
    "categoryId": 4
  },
  {
    "question": "해시 테이블(Hash Table)이란 무엇인가요?",
    "answer": "해시 테이블은 키를 해시 함수로 변환하여 데이터를 저장하는 자료구조로, 빠른 검색과 삽입이 가능합니다.",
    "categoryId": 4
  },
  {
    "question": "해시 충돌(Hash Collision)이란 무엇인가요?",
    "answer": "해시 충돌은 서로 다른 키가 같은 해시 값을 갖는 상황으로, 이를 해결하기 위해 체이닝 또는 오픈 어드레싱 등의 기법을 사용합니다.",
    "categoryId": 4
  },
  {
    "question": "이진 트리(Binary Tree)란 무엇인가요?",
    "answer": "이진 트리는 각 노드가 최대 두 개의 자식 노드를 가지는 트리 자료구조입니다.",
    "categoryId": 4
  },
  {
    "question": "이진 탐색 트리(Binary Search Tree, BST)란 무엇인가요?",
    "answer": "이진 탐색 트리는 왼쪽 자식 노드는 부모 노드보다 작고, 오른쪽 자식 노드는 부모 노드보다 큰 값을 가지는 트리입니다.",
    "categoryId": 4
  },
  {
    "question": "힙(Heap)이란 무엇인가요?",
    "answer": "힙은 완전 이진 트리 형태의 자료구조로, 최대 힙은 부모 노드가 자식 노드보다 크고, 최소 힙은 부모 노드가 자식 노드보다 작습니다.",
    "categoryId": 4
  },
  {
    "question": "우선순위 큐(Priority Queue)란 무엇인가요?",
    "answer": "우선순위 큐는 각 요소가 우선순위를 가지고 있으며, 우선순위가 높은 요소가 먼저 처리되는 큐입니다. 주로 힙으로 구현됩니다.",
    "categoryId": 4
  },
  {
    "question": "그래프(Graph)란 무엇인가요?",
    "answer": "그래프는 노드와 노드 간의 연결(엣지)로 이루어진 자료구조로, 다양한 관계를 나타낼 수 있습니다.",
    "categoryId": 4
  },
  {
    "question": "그래프의 인접 행렬(Adjacency Matrix)과 인접 리스트(Adjacency List)의 차이점은 무엇인가요?",
    "answer": "인접 행렬은 정점 간의 연결을 2차원 배열로 나타내고, 인접 리스트는 각 정점에 연결된 노드를 리스트로 저장하는 방식입니다.",
    "categoryId": 4
  },
  {
    "question": "깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)의 차이점은 무엇인가요?",
    "answer": "DFS는 한 경로를 끝까지 탐색하고 돌아오는 방식이고, BFS는 동일 레벨의 노드를 먼저 탐색하는 방식입니다.",
    "categoryId": 4
  },
  {
    "question": "트리와 그래프의 차이점은 무엇인가요?",
    "answer": "트리는 사이클이 없는 연결된 그래프이며, 그래프는 노드 간의 모든 연결을 포함할 수 있으며 사이클이 존재할 수 있습니다.",
    "categoryId": 4
  },
  {
    "question": "자기 균형 이진 탐색 트리(Self-balancing Binary Search Tree)란 무엇인가요?",
    "answer": "자기 균형 이진 탐색 트리는 삽입 및 삭제 후에도 트리 높이가 일정하도록 유지하는 트리로, AVL 트리와 레드-블랙 트리가 있습니다.",
    "categoryId": 4
  },
  {
    "question": "AVL 트리란 무엇인가요?",
    "answer": "AVL 트리는 각 노드의 왼쪽과 오른쪽 서브트리의 높이 차이가 1 이하로 유지되는 자기 균형 이진 탐색 트리입니다.",
    "categoryId": 4
  },
  {
    "question": "레드-블랙 트리(Red-Black Tree)란 무엇인가요?",
    "answer": "레드-블랙 트리는 노드가 적색 또는 흑색으로 색칠된 자기 균형 이진 탐색 트리로, 삽입과 삭제 후에도 트리의 균형을 유지합니다.",
    "categoryId": 4
  },
  {
    "question": "동적 배열(Dynamic Array)이란 무엇인가요?",
    "answer": "동적 배열은 크기를 동적으로 조절할 수 있는 배열로, 배열이 가득 차면 더 큰 배열로 복사하여 크기를 확장합니다.",
    "categoryId": 4
  },
  {
    "question": "배열(Array)의 시간 복잡도는 무엇인가요?",
    "answer": "배열에서 특정 요소 접근은 O(1), 삽입과 삭제는 O(n)의 시간 복잡도를 가집니다.",
    "categoryId": 4
  },
  {
    "question": "링크드 리스트(Linked List)의 시간 복잡도는 무엇인가요?",
    "answer": "링크드 리스트에서 특정 요소 접근은 O(n), 삽입과 삭제는 O(1)의 시간 복잡도를 가집니다.",
    "categoryId": 4
  },
  {
    "question": "이진 탐색(Binary Search)이란 무엇인가요?",
    "answer": "이진 탐색은 정렬된 배열에서 중간 요소와 비교하여 절반씩 범위를 좁혀가며 값을 찾는 탐색 알고리즘입니다. 시간 복잡도는 O(log n)입니다.",
    "categoryId": 4
  },
  {
    "question": "순차 탐색(Linear Search)이란 무엇인가요?",
    "answer": "순차 탐색은 배열의 처음부터 끝까지 차례대로 값을 비교하며 찾는 탐색 방법으로, 시간 복잡도는 O(n)입니다.",
    "categoryId": 4
  },
  {
    "question": "버블 정렬(Bubble Sort)이란 무엇인가요?",
    "answer": "버블 정렬은 인접한 두 요소를 비교하여 큰 값을 뒤로 보내는 방식의 정렬 알고리즘으로, 시간 복잡도는 O(n^2)입니다.",
    "categoryId": 4
  },
  {
    "question": "퀵 정렬(Quick Sort)이란 무엇인가요?",
    "answer": "퀵 정렬은 기준점을 설정하고 그보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할하여 재귀적으로 정렬하는 알고리즘으로, 평균 시간 복잡도는 O(n log n)입니다.",
    "categoryId": 4
  },
  {
    "question": "병합 정렬(Merge Sort)이란 무엇인가요?",
    "answer": "병합 정렬은 배열을 반으로 나누고 각각을 정렬한 후 병합하는 방식의 정렬 알고리즘으로, 시간 복잡도는 O(n log n)입니다.",
    "categoryId": 4
  },
  {
    "question": "삽입 정렬(Insertion Sort)이란 무엇인가요?",
    "answer": "삽입 정렬은 배열의 요소를 하나씩 확인하면서 이미 정렬된 부분에 적절한 위치에 삽입하는 방식으로, 시간 복잡도는 O(n^2)입니다.",
    "categoryId": 4
  },
  {
    "question": "선택 정렬(Selection Sort)이란 무엇인가요?",
    "answer": "선택 정렬은 매번 배열에서 가장 작은(또는 큰) 값을 찾아 정렬되지 않은 부분의 첫 번째 요소와 교환하는 방식입니다. 시간 복잡도는 O(n^2)입니다.",
    "categoryId": 4
  },
  {
    "question": "데크(Deque, Double-Ended Queue)란 무엇인가요?",
    "answer": "데크는 양쪽 끝에서 삽입과 삭제가 모두 가능한 큐의 일종으로, 앞뒤로 데이터를 추가하거나 제거할 수 있습니다.",
    "categoryId": 4
  },
  {
    "question": "원형 큐(Circular Queue)란 무엇인가요?",
    "answer": "원형 큐는 배열의 양쪽 끝이 연결된 형태의 큐로, 마지막 위치에서 다시 처음 위치로 돌아와서 데이터를 추가하거나 삭제할 수 있습니다.",
    "categoryId": 4
  },
  {
    "question": "트라이(Trie) 자료구조란 무엇인가요?",
    "answer": "트라이는 문자열을 효율적으로 저장하고 검색하기 위한 트리 구조로, 각 노드는 문자열의 접두사를 표현합니다.",
    "categoryId": 4
  },
  {
    "question": "이진 트리의 순회 방식에는 어떤 것들이 있나요?",
    "answer": "이진 트리 순회 방식에는 전위 순회(Pre-order), 중위 순회(In-order), 후위 순회(Post-order) 및 레벨 순서 순회(Level-order)가 있습니다.",
    "categoryId": 4
  },
  {
    "question": "B-트리(B-tree)란 무엇인가요?",
    "answer": "B-트리는 균형 잡힌 다방향 검색 트리로, 데이터베이스나 파일 시스템과 같은 대용량 데이터를 저장하는 데 적합한 자료구조입니다.",
    "categoryId": 4
  },
  {
    "question": "균형 트리(Balanced Tree)란 무엇인가요?",
    "answer": "균형 트리는 삽입 및 삭제 후에도 트리의 높이가 일정하게 유지되도록 설계된 트리로, 데이터 접근 시간을 최소화할 수 있습니다.",
    "categoryId": 4
  },
  {
    "question": "스택을 사용한 DFS(Depth First Search)의 시간 복잡도는 무엇인가요?",
    "answer": "DFS의 시간 복잡도는 그래프의 정점 수를 V, 간선 수를 E라고 할 때 O(V + E)입니다.",
    "categoryId": 4
  },
  {
    "question": "큐를 사용한 BFS(Breadth First Search)의 시간 복잡도는 무엇인가요?",
    "answer": "BFS의 시간 복잡도는 그래프의 정점 수를 V, 간선 수를 E라고 할 때 O(V + E)입니다.",
    "categoryId": 4
  },
  {
    "question": "해시 함수(Hash Function)란 무엇인가요?",
    "answer": "해시 함수는 임의의 크기의 데이터를 고정된 크기의 값으로 변환하는 함수로, 해시 테이블에서 데이터의 빠른 검색을 위해 사용됩니다.",
    "categoryId": 4
  },
  {
    "question": "이중 해시(Double Hashing)란 무엇인가요?",
    "answer": "이중 해시는 두 개의 해시 함수를 사용하여 해시 충돌을 해결하는 방식으로, 두 번째 해시 함수를 충돌 발생 시 사용합니다.",
    "categoryId": 4
  },
  {
    "question": "우선순위 큐에서의 삽입과 삭제 연산의 시간 복잡도는 무엇인가요?",
    "answer": "우선순위 큐에서의 삽입과 삭제 연산의 시간 복잡도는 힙을 사용할 경우 O(log n)입니다.",
    "categoryId": 4
  },
  {
    "question": "힙 정렬(Heap Sort)이란 무엇인가요?",
    "answer": "힙 정렬은 최대 힙이나 최소 힙을 이용하여 정렬하는 알고리즘으로, 시간 복잡도는 O(n log n)입니다.",
    "categoryId": 4
  },
  {
    "question": "스택을 사용하여 괄호의 짝을 확인하는 방법은 무엇인가요?",
    "answer": "여는 괄호를 스택에 저장하고, 닫는 괄호가 나왔을 때 스택에서 대응하는 여는 괄호를 꺼내 비교하는 방식으로 짝을 확인할 수 있습니다.",
    "categoryId": 4
  },
  {
    "question": "트리의 높이와 깊이의 차이점은 무엇인가요?",
    "answer": "트리의 높이는 루트에서 가장 먼 노드까지의 거리이고, 깊이는 루트에서 특정 노드까지의 거리입니다.",
    "categoryId": 4
  },
  {
    "question": "간선(Edge)이란 무엇인가요?",
    "answer": "간선은 그래프에서 두 노드를 연결하는 선으로, 노드 간의 관계나 경로를 나타냅니다.",
    "categoryId": 4
  },
  {
    "question": "최대 힙(Max Heap)과 최소 힙(Min Heap)의 차이점은 무엇인가요?",
    "answer": "최대 힙은 부모 노드가 자식 노드보다 크고, 최소 힙은 부모 노드가 자식 노드보다 작은 완전 이진 트리입니다.",
    "categoryId": 4
  },
  {
    "question": "동적 프로그래밍(Dynamic Programming)에서 사용하는 메모이제이션(Memoization)이란 무엇인가요?",
    "answer": "메모이제이션은 동적 프로그래밍에서 계산한 값을 저장해 두고, 동일한 계산이 필요할 때 다시 계산하지 않고 저장된 값을 사용하는 기법입니다.",
    "categoryId": 4
  },
  {
    "question": "배열과 리스트의 장단점은 무엇인가요?",
    "answer": "배열은 접근 속도가 빠르지만 크기가 고정되고, 리스트는 크기가 동적으로 조절되지만 접근 속도가 느립니다.",
    "categoryId": 4
  },
  {
    "question": "이진 트리의 최대 높이는 무엇인가요?",
    "answer": "이진 트리의 최대 높이는 트리의 노드 수를 n이라고 할 때, n일 수 있으며 모든 노드가 한쪽으로 치우친 경우입니다.",
    "categoryId": 4
  },
  {
    "question": "완전 이진 트리(Complete Binary Tree)란 무엇인가요?",
    "answer": "완전 이진 트리는 마지막 레벨을 제외하고 모든 레벨이 꽉 차 있으며, 마지막 레벨은 왼쪽부터 순서대로 채워진 이진 트리입니다.",
    "categoryId": 4
  },
  {
    "question": "포화 이진 트리(Full Binary Tree)란 무엇인가요?",
    "answer": "포화 이진 트리는 모든 노드가 두 개의 자식 노드를 가지거나, 자식 노드가 없는 트리입니다.",
    "categoryId": 4
  },
  {
    "question": "그래프에서 사이클(Cycle)이란 무엇인가요?",
    "answer": "사이클은 그래프에서 동일한 정점으로 다시 돌아오는 경로가 존재하는 경우를 의미합니다.",
    "categoryId": 4
  },
  {
    "question": "양방향 그래프(Bidirectional Graph)란 무엇인가요?",
    "answer": "양방향 그래프는 두 정점 간에 양방향으로 간선이 존재하는 그래프로, 두 정점이 서로 연결되어 있는 상태입니다.",
    "categoryId": 4
  },
  {
    "question": "연결 리스트에서 중복 노드를 제거하는 방법은 무엇인가요?",
    "answer": "해시셋을 사용하여 이미 등장한 값을 기록하고, 새로운 노드를 추가할 때 해시셋에 해당 값이 있는지 확인하여 중복을 제거합니다.",
    "categoryId": 4
  },
  {
    "question": "동적 배열의 장점과 단점은 무엇인가요?",
    "answer": "동적 배열은 크기를 유연하게 확장할 수 있지만, 배열이 가득 찼을 때 새로운 배열로 복사하는 과정에서 오버헤드가 발생합니다.",
    "categoryId": 4
  },
  {
    "question": "해시 테이블에서 체이닝(Chaining)이란 무엇인가요?",
    "answer": "체이닝은 해시 충돌을 해결하기 위해 해시 테이블의 각 인덱스에 연결 리스트를 사용하여 동일한 해시 값을 가진 항목을 저장하는 방식입니다.",
    "categoryId": 4
  },
  {
    "question": "해시 테이블의 성능을 개선하는 방법은 무엇인가요?",
    "answer": "해시 테이블의 성능을 개선하려면 해시 함수를 잘 설계하고, 충돌 해결 방식을 효율적으로 선택하며, 적절한 로드 팩터를 유지해야 합니다.",
    "categoryId": 4
  },
  {
    "question": "링크드 리스트에서 중간에 요소를 삽입하는 시간 복잡도는 무엇인가요?",
    "answer": "링크드 리스트에서 중간 요소를 삽입하는 시간 복잡도는 O(n)입니다, 리스트를 순회하여 적절한 위치를 찾아야 하기 때문입니다.",
    "categoryId": 4
  },
  {
    "question": "이진 탐색 트리에서 삽입 연산의 시간 복잡도는 무엇인가요?",
    "answer": "이진 탐색 트리에서 삽입 연산의 평균 시간 복잡도는 O(log n)이지만, 최악의 경우 O(n)이 될 수 있습니다.",
    "categoryId": 4
  },
  {
    "question": "깊이 우선 탐색(DFS)에서 백트래킹(Backtracking)이란 무엇인가요?",
    "answer": "백트래킹은 DFS에서 경로가 더 이상 진행될 수 없을 때, 이전 노드로 돌아가서 다른 경로를 탐색하는 기법입니다.",
    "categoryId": 4
  },
  {
    "question": "그래프의 가중치(Weight)란 무엇인가요?",
    "answer": "그래프의 가중치는 두 노드 간의 연결에 할당된 값으로, 경로의 비용이나 거리 등을 나타냅니다.",
    "categoryId": 4
  },
  {
    "question": "최소 신장 트리(MST, Minimum Spanning Tree)란 무엇인가요?",
    "answer": "최소 신장 트리는 그래프의 모든 정점을 연결하는 최소 비용의 간선들로 이루어진 부분 그래프입니다.",
    "categoryId": 4
  },
  {
    "question": "크루스칼 알고리즘(Kruskal's Algorithm)이란 무엇인가요?",
    "answer": "크루스칼 알고리즘은 가중치가 있는 그래프에서 최소 신장 트리를 찾는 알고리즘으로, 간선들을 가중치 순서대로 선택해 트리를 구성합니다.",
    "categoryId": 4
  },
  {
    "question": "프림 알고리즘(Prim's Algorithm)이란 무엇인가요?",
    "answer": "프림 알고리즘은 하나의 정점에서 시작해 인접한 정점 중 가장 작은 가중치를 가진 간선을 선택하며 최소 신장 트리를 구성하는 알고리즘입니다.",
    "categoryId": 4
  },
  {
    "question": "위상 정렬(Topological Sort)이란 무엇인가요?",
    "answer": "위상 정렬은 방향 그래프에서 각 정점의 선후 관계를 유지하면서 정렬하는 방법으로, 주로 작업 스케줄링에 사용됩니다.",
    "categoryId": 4
  },
  {
    "question": "자료구조에서의 버퍼(Buffer)란 무엇인가요?",
    "answer": "버퍼는 데이터를 일시적으로 저장하는 메모리 영역으로, 생산자와 소비자 간의 데이터 흐름을 조절하거나 입력과 출력을 효율적으로 처리하는 데 사용됩니다.",
    "categoryId": 4
  },
  {
    "question": "알고리즘이란 무엇인가요?",
    "answer": "알고리즘은 문제를 해결하기 위한 절차나 단계의 집합으로, 입력을 받아 처리한 후 원하는 결과를 출력하는 일련의 과정입니다.",
    "categoryId": 5
  },
  {
    "question": "시간 복잡도(Time Complexity)란 무엇인가요?",
    "answer": "시간 복잡도는 알고리즘이 실행되는 데 걸리는 시간을 입력 크기에 대한 함수로 표현한 것으로, 알고리즘의 효율성을 평가하는 지표입니다.",
    "categoryId": 5
  },
  {
    "question": "공간 복잡도(Space Complexity)란 무엇인가요?",
    "answer": "공간 복잡도는 알고리즘이 실행될 때 사용하는 메모리 공간의 양을 입력 크기에 대한 함수로 나타낸 것입니다.",
    "categoryId": 5
  },
  {
    "question": "시간 복잡도에서 빅오 표기법(Big-O Notation)이란 무엇인가요?",
    "answer": "빅오 표기법은 입력 크기가 커질 때 알고리즘의 시간 복잡도가 어떻게 증가하는지를 나타내는 표기법으로, 최악의 경우를 표현합니다.",
    "categoryId": 5
  },
  {
    "question": "알고리즘의 최선, 평균, 최악의 경우란 무엇인가요?",
    "answer": "최선은 알고리즘이 가장 빠르게 동작하는 경우, 평균은 일반적인 경우, 최악은 가장 느리게 동작하는 경우를 의미합니다.",
    "categoryId": 5
  },
  {
    "question": "정렬 알고리즘이란 무엇인가요?",
    "answer": "정렬 알고리즘은 주어진 데이터를 특정 순서대로 정렬하는 방법으로, 대표적으로 버블 정렬, 퀵 정렬, 병합 정렬 등이 있습니다.",
    "categoryId": 5
  },
  {
    "question": "버블 정렬의 시간 복잡도는 무엇인가요?",
    "answer": "버블 정렬의 시간 복잡도는 O(n^2)로, 모든 요소를 반복적으로 비교하여 정렬하는 비효율적인 정렬 알고리즘입니다.",
    "categoryId": 5
  },
  {
    "question": "퀵 정렬의 시간 복잡도는 무엇인가요?",
    "answer": "퀵 정렬의 평균 시간 복잡도는 O(n log n)이고, 최악의 경우 O(n^2)입니다. 효율적이지만 피벗 선택에 따라 성능이 달라집니다.",
    "categoryId": 5
  },
  {
    "question": "병합 정렬의 시간 복잡도는 무엇인가요?",
    "answer": "병합 정렬의 시간 복잡도는 O(n log n)이며, 데이터를 반으로 나누어 각각을 정렬한 후 병합하는 방식으로 동작합니다.",
    "categoryId": 5
  },
  {
    "question": "삽입 정렬의 시간 복잡도는 무엇인가요?",
    "answer": "삽입 정렬의 평균 및 최악의 시간 복잡도는 O(n^2)로, 요소를 하나씩 정렬된 부분에 삽입하는 방식입니다.",
    "categoryId": 5
  },
  {
    "question": "선택 정렬의 시간 복잡도는 무엇인가요?",
    "answer": "선택 정렬의 시간 복잡도는 O(n^2)로, 배열에서 가장 작은 요소를 찾아 정렬된 부분에 교환하는 방식입니다.",
    "categoryId": 5
  },
  {
    "question": "힙 정렬의 시간 복잡도는 무엇인가요?",
    "answer": "힙 정렬의 시간 복잡도는 O(n log n)으로, 힙 자료구조를 이용해 최대값 또는 최소값을 찾아가며 정렬합니다.",
    "categoryId": 5
  },
  {
    "question": "계수 정렬(Counting Sort)이란 무엇인가요?",
    "answer": "계수 정렬은 정수 형태의 데이터를 대상으로 하는 정렬 알고리즘으로, 각 값의 출현 횟수를 세어 정렬합니다. 시간 복잡도는 O(n + k)입니다.",
    "categoryId": 5
  },
  {
    "question": "기수 정렬(Radix Sort)이란 무엇인가요?",
    "answer": "기수 정렬은 데이터를 자리수 별로 나누어 각 자리수를 정렬하는 방식으로, 시간 복잡도는 O(d*(n + k))입니다.",
    "categoryId": 5
  },
  {
    "question": "탐욕 알고리즘(Greedy Algorithm)이란 무엇인가요?",
    "answer": "탐욕 알고리즘은 매 단계에서 가장 최선의 선택을 하는 방식으로, 전체 최적 해를 보장하지는 않지만 빠르게 근사 해를 찾을 수 있습니다.",
    "categoryId": 5
  },
  {
    "question": "동적 프로그래밍(Dynamic Programming)이란 무엇인가요?",
    "answer": "동적 프로그래밍은 문제를 작은 부분 문제로 나누어 해결한 결과를 저장하고, 이를 바탕으로 전체 문제를 해결하는 알고리즘입니다.",
    "categoryId": 5
  },
  {
    "question": "분할 정복(Divide and Conquer) 알고리즘이란 무엇인가요?",
    "answer": "분할 정복은 문제를 작은 하위 문제로 나누어 각각을 해결한 후, 결과를 합쳐 전체 문제를 해결하는 방식입니다.",
    "categoryId": 5
  },
  {
    "question": "백트래킹(Backtracking)이란 무엇인가요?",
    "answer": "백트래킹은 가능한 모든 경우를 탐색하며 해를 찾는 알고리즘으로, 해가 아니라고 판단되면 되돌아가 다른 경로를 탐색합니다.",
    "categoryId": 5
  },
  {
    "question": "그래프 탐색에서 DFS(Depth First Search)와 BFS(Breadth First Search)의 차이점은 무엇인가요?",
    "answer": "DFS는 한 경로를 끝까지 탐색한 후 다른 경로를 탐색하는 방식이고, BFS는 동일 레벨의 모든 노드를 먼저 탐색하는 방식입니다.",
    "categoryId": 5
  },
  {
    "question": "다익스트라 알고리즘(Dijkstra’s Algorithm)이란 무엇인가요?",
    "answer": "다익스트라 알고리즘은 가중치가 있는 그래프에서 하나의 정점에서 다른 모든 정점으로의 최단 경로를 찾는 알고리즘입니다.",
    "categoryId": 5
  },
  {
    "question": "플로이드-워셜 알고리즘(Floyd-Warshall Algorithm)이란 무엇인가요?",
    "answer": "플로이드-워셜 알고리즘은 그래프에서 모든 정점 간의 최단 경로를 찾는 알고리즘으로, 동적 프로그래밍을 사용하여 해결합니다.",
    "categoryId": 5
  },
  {
    "question": "벨만-포드 알고리즘(Bellman-Ford Algorithm)이란 무엇인가요?",
    "answer": "벨만-포드 알고리즘은 음수 가중치를 허용하는 그래프에서 최단 경로를 찾는 알고리즘으로, 다익스트라 알고리즘과 달리 음수 사이클도 탐지할 수 있습니다.",
    "categoryId": 5
  },
  {
    "question": "최소 신장 트리(Minimum Spanning Tree, MST)란 무엇인가요?",
    "answer": "최소 신장 트리는 그래프의 모든 정점을 연결하는 최소 비용의 간선 집합을 찾는 문제로, 크루스칼(Kruskal)과 프림(Prim) 알고리즘이 있습니다.",
    "categoryId": 5
  },
  {
    "question": "크루스칼 알고리즘(Kruskal’s Algorithm)이란 무엇인가요?",
    "answer": "크루스칼 알고리즘은 간선의 가중치가 작은 순서대로 선택하여 최소 신장 트리를 만드는 알고리즘입니다.",
    "categoryId": 5
  },
  {
    "question": "프림 알고리즘(Prim’s Algorithm)이란 무엇인가요?",
    "answer": "프림 알고리즘은 시작 정점에서 출발하여 연결된 가장 작은 가중치의 간선을 선택해 나가며 최소 신장 트리를 구성하는 방식입니다.",
    "categoryId": 5
  },
  {
    "question": "위상 정렬(Topological Sort)이란 무엇인가요?",
    "answer": "위상 정렬은 방향 그래프에서 각 정점의 선후 관계를 유지하며 정렬하는 방법으로, 주로 작업 스케줄링 문제에 사용됩니다.",
    "categoryId": 5
  },
  {
    "question": "최대 공약수(GCD, Greatest Common Divisor)를 구하는 유클리드 알고리즘이란 무엇인가요?",
    "answer": "유클리드 알고리즘은 두 수의 최대 공약수를 구하는 알고리즘으로, 큰 수를 작은 수로 나눈 나머지와 작은 수로 반복적으로 나누는 방식입니다.",
    "categoryId": 5
  },
  {
    "question": "최소 공배수(LCM, Least Common Multiple)를 구하는 방법은 무엇인가요?",
    "answer": "두 수의 최소 공배수는 두 수의 곱을 최대 공약수로 나누어 구할 수 있습니다. LCM(a, b) = (a * b) / GCD(a, b)입니다.",
    "categoryId": 5
  },
  {
    "question": "순열(Permutation)과 조합(Combination)의 차이점은 무엇인가요?",
    "answer": "순열은 순서를 고려한 배치 방식이고, 조합은 순서를 고려하지 않은 배치 방식입니다.",
    "categoryId": 5
  },
  {
    "question": "동적 프로그래밍과 탐욕 알고리즘의 차이점은 무엇인가요?",
    "answer": "동적 프로그래밍은 중복된 부분 문제를 저장하여 전체 문제를 해결하는 방식이고, 탐욕 알고리즘은 매 단계에서 최적의 선택을 하는 방식입니다.",
    "categoryId": 5
  },
  {
    "question": "분할 정복 알고리즘의 예시로는 무엇이 있나요?",
    "answer": "퀵 정렬과 병합 정렬이 대표적인 분할 정복 알고리즘입니다. 문제를 작은 부분으로 나누어 각각을 해결한 후 병합합니다.",
    "categoryId": 5
  },
  {
    "question": "탐욕 알고리즘이 항상 최적의 해를 보장하지 않는 이유는 무엇인가요?",
    "answer": "탐욕 알고리즘은 매 단계에서 가장 좋은 선택을 하지만, 전체적인 최적 해를 보장하지는 않으며, 지역 최적해에 머무를 수 있습니다.",
    "categoryId": 5
  },
  {
    "question": "피보나치 수열을 동적 프로그래밍으로 해결하는 방법은 무엇인가요?",
    "answer": "동적 프로그래밍으로 피보나치 수열을 해결할 때, 이전에 계산한 값을 저장하여 동일한 계산을 반복하지 않고 재사용하여 성능을 향상시킵니다.",
    "categoryId": 5
  },
  {
    "question": "탐색 알고리즘에서 이진 탐색(Binary Search)이란 무엇인가요?",
    "answer": "이진 탐색은 정렬된 배열에서 중간 값을 기준으로 탐색 범위를 절반씩 줄여가며 값을 찾는 알고리즘으로, 시간 복잡도는 O(log n)입니다.",
    "categoryId": 5
  },
  {
    "question": "순차 탐색(Linear Search)의 시간 복잡도는 무엇인가요?",
    "answer": "순차 탐색은 처음부터 끝까지 차례대로 값을 비교하며 탐색하는 방식으로, 시간 복잡도는 O(n)입니다.",
    "categoryId": 5
  },
  {
    "question": "이진 탐색 트리(Binary Search Tree, BST)에서 탐색의 시간 복잡도는 무엇인가요?",
    "answer": "이진 탐색 트리에서 탐색의 평균 시간 복잡도는 O(log n)이지만, 트리가 편향되면 최악의 경우 O(n)이 될 수 있습니다.",
    "categoryId": 5
  },
  {
    "question": "해시 알고리즘(Hash Algorithm)이란 무엇인가요?",
    "answer": "해시 알고리즘은 데이터를 고정된 크기의 해시 값으로 변환하는 함수로, 해시 테이블에서 데이터를 빠르게 검색하기 위해 사용됩니다.",
    "categoryId": 5
  },
  {
    "question": "DFS(깊이 우선 탐색)의 시간 복잡도는 무엇인가요?",
    "answer": "DFS의 시간 복잡도는 그래프의 정점 수를 V, 간선 수를 E라고 할 때 O(V + E)입니다.",
    "categoryId": 5
  },
  {
    "question": "BFS(너비 우선 탐색)의 시간 복잡도는 무엇인가요?",
    "answer": "BFS의 시간 복잡도는 그래프의 정점 수를 V, 간선 수를 E라고 할 때 O(V + E)입니다.",
    "categoryId": 5
  },
  {
    "question": "피보나치 수열을 재귀적으로 해결할 때 시간 복잡도는 무엇인가요?",
    "answer": "재귀적으로 피보나치 수열을 해결할 때 중복 계산이 발생하여 시간 복잡도는 O(2^n)입니다.",
    "categoryId": 5
  },
  {
    "question": "탐욕 알고리즘의 대표적인 예시는 무엇인가요?",
    "answer": "탐욕 알고리즘의 대표적인 예시로는 '거스름돈 문제'와 '활동 선택 문제'가 있으며, 각 단계에서 최적의 선택을 합니다.",
    "categoryId": 5
  },
  {
    "question": "TSP(Traveling Salesman Problem) 문제란 무엇인가요?",
    "answer": "TSP 문제는 주어진 도시들을 모두 방문한 후 다시 시작점으로 돌아오는 경로 중 가장 짧은 경로를 찾는 문제입니다.",
    "categoryId": 5
  },
  {
    "question": "알고리즘에서 최적화 문제란 무엇인가요?",
    "answer": "최적화 문제는 가능한 해 중에서 가장 최적의 해를 찾는 문제로, 비용을 최소화하거나 이익을 최대화하는 해를 구합니다.",
    "categoryId": 5
  },
  {
    "question": "탐욕 알고리즘이 효과적인 경우는 언제인가요?",
    "answer": "탐욕 알고리즘은 문제의 부분 해들이 최적해의 일부가 될 때 효과적이며, 대표적으로 '활동 선택 문제'나 '프림 알고리즘'이 있습니다.",
    "categoryId": 5
  },
  {
    "question": "플로이드-워셜 알고리즘의 시간 복잡도는 무엇인가요?",
    "answer": "플로이드-워셜 알고리즘의 시간 복잡도는 O(V^3)로, 그래프의 모든 정점 간 최단 경로를 계산합니다.",
    "categoryId": 5
  },
  {
    "question": "알고리즘에서 분기 한정법(Branch and Bound)이란 무엇인가요?",
    "answer": "분기 한정법은 상태 공간 트리를 생성해 가능한 해를 찾고, 불가능하거나 비효율적인 경로는 가지치기하여 탐색을 줄이는 기법입니다.",
    "categoryId": 5
  },
  {
    "question": "DFS(깊이 우선 탐색)에서 재귀와 스택을 사용하는 방식의 차이점은 무엇인가요?",
    "answer": "DFS는 재귀를 통해 자연스럽게 함수 호출 스택을 사용하거나, 명시적으로 스택 자료구조를 사용해 구현할 수 있습니다. 둘 다 결과는 동일합니다.",
    "categoryId": 5
  },
  {
    "question": "탐욕 알고리즘이 항상 최적의 해를 보장하는 문제는 무엇인가요?",
    "answer": "탐욕 알고리즘이 최적의 해를 보장하는 문제의 대표적인 예로 '프림 알고리즘'과 '크루스칼 알고리즘'이 있습니다.",
    "categoryId": 5
  },
  {
    "question": "알고리즘의 시간 복잡도를 분석하는 방법에는 무엇이 있나요?",
    "answer": "시간 복잡도를 분석하는 방법으로는 반복문 횟수 분석, 재귀 호출의 마스터 정리 사용, 각 단계의 연산 수를 계산하는 방식 등이 있습니다.",
    "categoryId": 5
  },
  {
    "question": "N-Queens 문제란 무엇인가요?",
    "answer": "N-Queens 문제는 N x N 체스판에 N개의 퀸을 서로 공격하지 않도록 배치하는 문제로, 백트래킹을 사용해 해결할 수 있습니다.",
    "categoryId": 5
  },
  {
    "question": "에라토스테네스의 체(Sieve of Eratosthenes)란 무엇인가요?",
    "answer": "에라토스테네스의 체는 소수를 구하는 알고리즘으로, 소수의 배수를 제거해 소수를 찾는 방식입니다. 시간 복잡도는 O(n log log n)입니다.",
    "categoryId": 5
  },
  {
    "question": "유니온 파인드(Union-Find) 알고리즘이란 무엇인가요?",
    "answer": "유니온 파인드 알고리즘은 서로소 집합을 관리하는 자료구조로, 합집합 연산과 찾기 연산을 효율적으로 처리할 수 있습니다.",
    "categoryId": 5
  },
  {
    "question": "알고리즘에서 메모이제이션(Memoization)이란 무엇인가요?",
    "answer": "메모이제이션은 동적 프로그래밍에서 중복된 계산을 피하기 위해 이미 계산한 값을 저장하고 재사용하는 기법입니다.",
    "categoryId": 5
  },
  {
    "question": "카누나 방정식 문제(Knapsack Problem)란 무엇인가요?",
    "answer": "카누나 방정식 문제는 주어진 무게 한도 내에서 물건들의 가치를 최대화하는 문제로, 동적 프로그래밍과 탐욕 알고리즘을 사용해 해결할 수 있습니다.",
    "categoryId": 5
  },
  {
    "question": "KMP 알고리즘이란 무엇인가요?",
    "answer": "KMP 알고리즘은 문자열 검색 알고리즘으로, 접두사와 접미사의 일치 정보를 이용해 불필요한 비교를 줄여 검색 속도를 향상시킵니다.",
    "categoryId": 5
  },
  {
    "question": "알고리즘에서 다이나믹 테이블이란 무엇인가요?",
    "answer": "다이나믹 테이블은 동적 프로그래밍에서 부분 문제의 해를 저장하는 테이블로, 이미 계산한 값을 저장해 중복 계산을 방지합니다.",
    "categoryId": 5
  },
  {
    "question": "라빈-카프(Rabin-Karp) 알고리즘이란 무엇인가요?",
    "answer": "라빈-카프 알고리즘은 해시 함수를 이용한 문자열 검색 알고리즘으로, 해시 값을 비교하여 문자열을 빠르게 검색합니다.",
    "categoryId": 5
  },
  {
    "question": "알고리즘에서 그리디 알고리즘의 사용 사례는 무엇인가요?",
    "answer": "그리디 알고리즘은 거스름돈 문제, 활동 선택 문제, 프림 알고리즘, 크루스칼 알고리즘 등에서 효과적으로 사용됩니다.",
    "categoryId": 5
  },
  {
    "question": "길찾기 알고리즘에서 A* 알고리즘이란 무엇인가요?",
    "answer": "A* 알고리즘은 최단 경로를 찾기 위한 휴리스틱 기반 탐색 알고리즘으로, 경로 비용과 휴리스틱 비용을 합산하여 최적 경로를 탐색합니다.",
    "categoryId": 5
  },
  {
    "question": "Flood Fill 알고리즘이란 무엇인가요?",
    "answer": "Flood Fill 알고리즘은 연결된 영역을 채우는 알고리즘으로, 그래픽 에디터에서 채우기 기능을 구현할 때 사용됩니다.",
    "categoryId": 5
  },
  {
    "question": "Manacher 알고리즘이란 무엇인가요?",
    "answer": "Manacher 알고리즘은 주어진 문자열에서 가장 긴 팰린드롬 부분 문자열을 선형 시간 복잡도(O(n)) 내에 찾는 알고리즘입니다.",
    "categoryId": 5
  },
  {
    "question": "데이터베이스(Database)란 무엇인가요?",
    "answer": "데이터베이스는 데이터를 체계적으로 저장하고 관리하는 시스템으로, 검색, 삽입, 삭제, 갱신 등의 작업을 효율적으로 처리할 수 있게 해줍니다.",
    "categoryId": 6
  },
  {
    "question": "DBMS(Database Management System)이란 무엇인가요?",
    "answer": "DBMS는 데이터베이스를 관리하고 데이터에 접근할 수 있도록 도와주는 소프트웨어로, SQL을 통해 데이터를 조회, 수정, 삭제할 수 있습니다.",
    "categoryId": 6
  },
  {
    "question": "SQL이란 무엇인가요?",
    "answer": "SQL(Structured Query Language)은 관계형 데이터베이스에서 데이터를 관리하고 조작하기 위한 표준 언어입니다.",
    "categoryId": 6
  },
  {
    "question": "관계형 데이터베이스(Relational Database)란 무엇인가요?",
    "answer": "관계형 데이터베이스는 데이터를 테이블 형태로 저장하며, 각 테이블 간의 관계를 정의할 수 있는 데이터베이스입니다.",
    "categoryId": 6
  },
  {
    "question": "기본키(Primary Key)란 무엇인가요?",
    "answer": "기본키는 테이블에서 각 행을 고유하게 식별할 수 있는 열 또는 열들의 집합으로, 중복 값을 가질 수 없습니다.",
    "categoryId": 6
  },
  {
    "question": "외래키(Foreign Key)란 무엇인가요?",
    "answer": "외래키는 한 테이블에서 다른 테이블의 기본키를 참조하는 열로, 테이블 간의 관계를 정의하는 데 사용됩니다.",
    "categoryId": 6
  },
  {
    "question": "트랜잭션(Transaction)이란 무엇인가요?",
    "answer": "트랜잭션은 데이터베이스에서 일련의 작업들을 하나의 작업 단위로 처리하는 것으로, 모두 성공하거나 모두 실패하는 원자성을 보장합니다.",
    "categoryId": 6
  },
  {
    "question": "트랜잭션의 ACID 속성이란 무엇인가요?",
    "answer": "ACID는 트랜잭션의 4가지 속성으로, 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability)을 의미합니다.",
    "categoryId": 6
  },
  {
    "question": "인덱스(Index)란 무엇인가요?",
    "answer": "인덱스는 테이블의 데이터를 빠르게 검색할 수 있도록 하는 자료 구조로, 특정 열의 값을 기반으로 정렬된 검색 성능을 향상시킵니다.",
    "categoryId": 6
  },
  {
    "question": "조인(Join)이란 무엇인가요?",
    "answer": "조인은 두 개 이상의 테이블에서 관련된 데이터를 결합하여 하나의 결과로 반환하는 SQL 연산입니다.",
    "categoryId": 6
  },
  {
    "question": "내부 조인(Inner Join)이란 무엇인가요?",
    "answer": "내부 조인은 두 테이블 간에 일치하는 데이터만을 반환하는 조인 방식으로, 조건에 맞지 않는 데이터는 제외됩니다.",
    "categoryId": 6
  },
  {
    "question": "외부 조인(Outer Join)이란 무엇인가요?",
    "answer": "외부 조인은 한쪽 테이블에만 일치하는 데이터도 반환하는 조인 방식으로, 일치하지 않는 데이터는 NULL로 표시됩니다.",
    "categoryId": 6
  },
  {
    "question": "LEFT JOIN과 RIGHT JOIN의 차이점은 무엇인가요?",
    "answer": "LEFT JOIN은 왼쪽 테이블의 모든 행을 반환하고, RIGHT JOIN은 오른쪽 테이블의 모든 행을 반환하며, 일치하지 않는 값은 NULL로 채워집니다.",
    "categoryId": 6
  },
  {
    "question": "SELF JOIN이란 무엇인가요?",
    "answer": "SELF JOIN은 동일한 테이블을 두 번 사용하여 자기 자신과 조인하는 방식으로, 테이블 내에서 연관된 데이터를 찾을 때 사용됩니다.",
    "categoryId": 6
  },
  {
    "question": "정규화(Normalization)란 무엇인가요?",
    "answer": "정규화는 데이터의 중복을 최소화하고, 테이블 간의 종속성을 줄여 데이터 무결성을 보장하는 데이터베이스 설계 방법입니다.",
    "categoryId": 6
  },
  {
    "question": "1NF(First Normal Form)이란 무엇인가요?",
    "answer": "1NF는 테이블 내의 각 열이 원자 값을 가져야 하고, 중복된 데이터가 없어야 하는 정규화의 첫 번째 단계입니다.",
    "categoryId": 6
  },
  {
    "question": "2NF(Second Normal Form)이란 무엇인가요?",
    "answer": "2NF는 1NF를 만족하면서, 기본키의 일부분에만 종속된 부분 종속성을 제거하여 데이터 무결성을 강화하는 정규화 단계입니다.",
    "categoryId": 6
  },
  {
    "question": "3NF(Third Normal Form)이란 무엇인가요?",
    "answer": "3NF는 2NF를 만족하면서, 기본키가 아닌 열이 다른 기본키가 아닌 열에 종속되지 않도록 하는 정규화 단계입니다.",
    "categoryId": 6
  },
  {
    "question": "반정규화(Denormalization)란 무엇인가요?",
    "answer": "반정규화는 성능 향상을 위해 정규화된 테이블을 다시 결합하거나 중복 데이터를 허용하는 방식으로, 데이터 접근 속도를 높이는 기법입니다.",
    "categoryId": 6
  },
  {
    "question": "데이터 무결성(Integrity)이란 무엇인가요?",
    "answer": "데이터 무결성은 데이터의 정확성과 일관성을 보장하는 속성으로, 데이터베이스에서 정확한 정보가 유지되도록 하는 것입니다.",
    "categoryId": 6
  },
  {
    "question": "SQL에서 GROUP BY절은 무엇을 하나요?",
    "answer": "GROUP BY절은 동일한 값을 가진 행들을 그룹으로 묶어 집계 함수와 함께 사용하여 각 그룹에 대한 집계 결과를 생성합니다.",
    "categoryId": 6
  },
  {
    "question": "HAVING절과 WHERE절의 차이점은 무엇인가요?",
    "answer": "WHERE절은 그룹핑되기 전에 행을 필터링하고, HAVING절은 그룹핑된 후 그룹에 대해 조건을 필터링합니다.",
    "categoryId": 6
  },
  {
    "question": "SQL에서 서브쿼리(Subquery)란 무엇인가요?",
    "answer": "서브쿼리는 다른 쿼리 내에 포함된 쿼리로, 주 쿼리의 결과에 영향을 미치는 보조 쿼리입니다.",
    "categoryId": 6
  },
  {
    "question": "트리거(Trigger)란 무엇인가요?",
    "answer": "트리거는 특정 테이블에 삽입, 수정, 삭제 등의 이벤트가 발생할 때 자동으로 실행되는 SQL 명령어 집합입니다.",
    "categoryId": 6
  },
  {
    "question": "뷰(View)란 무엇인가요?",
    "answer": "뷰는 하나 이상의 테이블을 기반으로 하는 가상 테이블로, 실제 데이터를 저장하지 않고 쿼리 결과를 보여주는 역할을 합니다.",
    "categoryId": 6
  },
  {
    "question": "데이터베이스 인덱스를 사용할 때의 장점과 단점은 무엇인가요?",
    "answer": "인덱스는 데이터 검색 속도를 높여주지만, 삽입, 삭제, 업데이트 시 인덱스도 갱신되어야 하므로 성능 저하가 발생할 수 있습니다.",
    "categoryId": 6
  },
  {
    "question": "샤딩(Sharding)이란 무엇인가요?",
    "answer": "샤딩은 대용량 데이터를 처리하기 위해 데이터베이스를 여러 개의 작은 조각으로 분할하여 저장하는 기법입니다.",
    "categoryId": 6
  },
  {
    "question": "파티셔닝(Partitioning)이란 무엇인가요?",
    "answer": "파티셔닝은 테이블을 논리적으로 나누어 관리하는 방식으로, 대규모 데이터를 효율적으로 관리하고 성능을 개선할 수 있습니다.",
    "categoryId": 6
  },
  {
    "question": "데이터베이스에서 클러스터링(Clustering)이란 무엇인가요?",
    "answer": "클러스터링은 비슷한 데이터를 물리적으로 가까운 위치에 저장하여 관련 데이터를 빠르게 조회할 수 있도록 하는 기법입니다.",
    "categoryId": 6
  },
  {
    "question": "데이터베이스에서 트랜잭션 격리 수준(Isolation Level)이란 무엇인가요?",
    "answer": "트랜잭션 격리 수준은 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치는 정도를 조정하는 방법으로, READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 네 가지가 있습니다.",
    "categoryId": 6
  },
  {
    "question": "READ COMMITTED와 REPEATABLE READ의 차이점은 무엇인가요?",
    "answer": "READ COMMITTED는 트랜잭션이 커밋된 데이터를 읽는 격리 수준이고, REPEATABLE READ는 트랜잭션 동안 동일한 데이터를 읽을 수 있도록 보장하는 격리 수준입니다.",
    "categoryId": 6
  },
  {
    "question": "데이터베이스에서 팬텀 리드(Phantom Read)란 무엇인가요?",
    "answer": "팬텀 리드는 트랜잭션이 진행 중일 때, 다른 트랜잭션이 데이터를 삽입하거나 삭제하여 읽을 수 있는 데이터의 수가 달라지는 현상입니다.",
    "categoryId": 6
  },
  {
    "question": "낙관적 잠금(Optimistic Locking)과 비관적 잠금(Pessimistic Locking)의 차이점은 무엇인가요?",
    "answer": "낙관적 잠금은 충돌이 거의 발생하지 않을 것이라 가정하고 트랜잭션을 진행하며, 비관적 잠금은 충돌 가능성을 염두에 두고 자원을 미리 잠급니다.",
    "categoryId": 6
  },
  {
    "question": "데이터베이스에서 교착 상태(Deadlock)이란 무엇인가요?",
    "answer": "교착 상태는 두 개 이상의 트랜잭션이 서로 상대방이 점유한 자원을 기다리며 무한정 대기하는 상황을 말합니다.",
    "categoryId": 6
  },
  {
    "question": "데이터베이스에서 인덱스 스캔(Index Scan)과 테이블 스캔(Table Scan)의 차이점은 무엇인가요?",
    "answer": "인덱스 스캔은 인덱스를 통해 데이터를 조회하는 방식이고, 테이블 스캔은 테이블의 모든 데이터를 순차적으로 조회하는 방식입니다.",
    "categoryId": 6
  },
  {
    "question": "데이터베이스에서 복제(Replication)란 무엇인가요?",
    "answer": "복제는 데이터를 여러 서버에 복사하여 동일한 데이터를 여러 곳에서 관리하는 방식으로, 가용성과 데이터 일관성을 높입니다.",
    "categoryId": 6
  },
  {
    "question": "NoSQL 데이터베이스란 무엇인가요?",
    "answer": "NoSQL 데이터베이스는 관계형 데이터베이스와 달리 테이블 구조가 아닌 비정형 데이터를 저장하고 처리하는 데 최적화된 데이터베이스입니다.",
    "categoryId": 6
  },
  {
    "question": "관계형 데이터베이스와 NoSQL 데이터베이스의 차이점은 무엇인가요?",
    "answer": "관계형 데이터베이스는 테이블 기반으로 스키마가 엄격하지만, NoSQL 데이터베이스는 스키마가 유연하고 비정형 데이터를 저장하는 데 적합합니다.",
    "categoryId": 6
  },
  {
    "question": "CAP 이론이란 무엇인가요?",
    "answer": "CAP 이론은 분산 시스템에서 일관성(Consistency), 가용성(Availability), 파티션 허용성(Partition Tolerance) 중 두 가지만 보장할 수 있다는 이론입니다.",
    "categoryId": 6
  },
  {
    "question": "일관성(Consistency), 가용성(Availability), 파티션 허용성(Partition Tolerance) 중 각각 무엇을 의미하나요?",
    "answer": "일관성은 모든 노드에 동일한 데이터가 존재하는 것을 보장하고, 가용성은 시스템이 항상 응답 가능한 상태를 의미하며, 파티션 허용성은 네트워크 분할 시에도 시스템이 동작함을 보장합니다.",
    "categoryId": 6
  },
  {
    "question": "MongoDB란 무엇인가요?",
    "answer": "MongoDB는 문서 지향 NoSQL 데이터베이스로, JSON과 유사한 형식으로 데이터를 저장하며 스키마가 유연하여 비정형 데이터를 처리하는 데 적합합니다.",
    "categoryId": 6
  },
  {
    "question": "Redis란 무엇인가요?",
    "answer": "Redis는 키-값(Key-Value) 구조로 데이터를 저장하는 인메모리 데이터베이스로, 매우 빠른 성능과 높은 가용성을 제공합니다.",
    "categoryId": 6
  },
  {
    "question": "데이터베이스에서 샤딩(Sharding)과 파티셔닝(Partitioning)의 차이점은 무엇인가요?",
    "answer": "샤딩은 데이터를 여러 물리적 서버에 분산하여 저장하는 방식이고, 파티셔닝은 테이블을 논리적으로 나누어 하나의 서버 내에서 관리하는 방식입니다.",
    "categoryId": 6
  },
  {
    "question": "ACID 속성에서 '원자성(Atomicity)'이란 무엇인가요?",
    "answer": "원자성은 트랜잭션 내의 모든 작업이 완전히 수행되거나 전혀 수행되지 않음을 보장하는 속성입니다.",
    "categoryId": 6
  },
  {
    "question": "ACID 속성에서 '일관성(Consistency)'이란 무엇인가요?",
    "answer": "일관성은 트랜잭션이 완료된 후에도 데이터베이스가 유효한 상태를 유지하며, 모든 비즈니스 규칙이 충족됨을 보장하는 속성입니다.",
    "categoryId": 6
  },
  {
    "question": "ACID 속성에서 '격리성(Isolation)'이란 무엇인가요?",
    "answer": "격리성은 하나의 트랜잭션이 완료되기 전까지 다른 트랜잭션이 그 결과를 참조하거나 변경할 수 없도록 보장하는 속성입니다.",
    "categoryId": 6
  },
  {
    "question": "ACID 속성에서 '지속성(Durability)'이란 무엇인가요?",
    "answer": "지속성은 트랜잭션이 성공적으로 완료된 후에 그 결과가 영구적으로 반영되며, 시스템 장애가 발생해도 데이터가 유실되지 않음을 보장하는 속성입니다.",
    "categoryId": 6
  },
  {
    "question": "SQL Injection 공격이란 무엇인가요?",
    "answer": "SQL Injection은 악의적인 사용자가 SQL 문에 악성 코드를 삽입하여 데이터베이스를 공격하거나 조작하는 기법입니다.",
    "categoryId": 6
  },
  {
    "question": "데이터베이스에서 '쓰기 스케일링(Write Scaling)'이란 무엇인가요?",
    "answer": "쓰기 스케일링은 데이터를 분산하여 여러 노드에서 동시에 쓰기 작업을 처리함으로써 데이터베이스의 성능을 향상시키는 기법입니다.",
    "categoryId": 6
  },
  {
    "question": "데이터베이스에서 '읽기 스케일링(Read Scaling)'이란 무엇인가요?",
    "answer": "읽기 스케일링은 데이터의 복제본을 여러 서버에 분산하여 읽기 작업을 분산 처리함으로써 성능을 향상시키는 기법입니다.",
    "categoryId": 6
  },
  {
    "question": "ORM(Object-Relational Mapping)이란 무엇인가요?",
    "answer": "ORM은 객체 지향 프로그래밍에서 객체를 데이터베이스의 테이블과 자동으로 매핑하여 SQL 없이 데이터베이스를 조작할 수 있게 해주는 기술입니다.",
    "categoryId": 6
  },
  {
    "question": "데이터베이스의 '장애 복구(Failover)'란 무엇인가요?",
    "answer": "장애 복구는 주 서버가 장애를 일으켰을 때, 백업 서버로 자동으로 전환하여 시스템이 중단 없이 계속 동작하도록 하는 방법입니다.",
    "categoryId": 6
  },
  {
    "question": "데이터베이스에서 '캐싱(Caching)'이란 무엇인가요?",
    "answer": "캐싱은 자주 참조되는 데이터를 메모리와 같은 빠른 저장소에 저장하여 데이터베이스에 대한 접근 시간을 줄이는 방법입니다.",
    "categoryId": 6
  },
  {
    "question": "데이터베이스에서 '백업(Backup)'이란 무엇인가요?",
    "answer": "백업은 데이터베이스의 데이터를 정기적으로 복사하여 시스템 장애나 데이터 손실에 대비해 데이터를 복원할 수 있도록 하는 방법입니다.",
    "categoryId": 6
  }
]